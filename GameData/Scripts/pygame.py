# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pygame', [dirname(__file__)])
        except ImportError:
            import _pygame
            return _pygame
        if fp is not None:
            try:
                _mod = imp.load_module('_pygame', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pygame = swig_import_helper()
    del swig_import_helper
else:
    import _pygame
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _pygame.SwigPyIterator_value(self)
    def incr(self, n = 1): return _pygame.SwigPyIterator_incr(self, n)
    def decr(self, n = 1): return _pygame.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _pygame.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _pygame.SwigPyIterator_equal(self, *args)
    def copy(self): return _pygame.SwigPyIterator_copy(self)
    def next(self): return _pygame.SwigPyIterator_next(self)
    def __next__(self): return _pygame.SwigPyIterator___next__(self)
    def previous(self): return _pygame.SwigPyIterator_previous(self)
    def advance(self, *args): return _pygame.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _pygame.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _pygame.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _pygame.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _pygame.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _pygame.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _pygame.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _pygame.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class EntityVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EntityVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EntityVector, name)
    __repr__ = _swig_repr
    def iterator(self): return _pygame.EntityVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _pygame.EntityVector___nonzero__(self)
    def __bool__(self): return _pygame.EntityVector___bool__(self)
    def __len__(self): return _pygame.EntityVector___len__(self)
    def pop(self): return _pygame.EntityVector_pop(self)
    def __getslice__(self, *args): return _pygame.EntityVector___getslice__(self, *args)
    def __setslice__(self, *args): return _pygame.EntityVector___setslice__(self, *args)
    def __delslice__(self, *args): return _pygame.EntityVector___delslice__(self, *args)
    def __delitem__(self, *args): return _pygame.EntityVector___delitem__(self, *args)
    def __getitem__(self, *args): return _pygame.EntityVector___getitem__(self, *args)
    def __setitem__(self, *args): return _pygame.EntityVector___setitem__(self, *args)
    def append(self, *args): return _pygame.EntityVector_append(self, *args)
    def empty(self): return _pygame.EntityVector_empty(self)
    def size(self): return _pygame.EntityVector_size(self)
    def clear(self): return _pygame.EntityVector_clear(self)
    def swap(self, *args): return _pygame.EntityVector_swap(self, *args)
    def get_allocator(self): return _pygame.EntityVector_get_allocator(self)
    def begin(self): return _pygame.EntityVector_begin(self)
    def end(self): return _pygame.EntityVector_end(self)
    def rbegin(self): return _pygame.EntityVector_rbegin(self)
    def rend(self): return _pygame.EntityVector_rend(self)
    def pop_back(self): return _pygame.EntityVector_pop_back(self)
    def erase(self, *args): return _pygame.EntityVector_erase(self, *args)
    def __init__(self, *args): 
        this = _pygame.new_EntityVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _pygame.EntityVector_push_back(self, *args)
    def front(self): return _pygame.EntityVector_front(self)
    def back(self): return _pygame.EntityVector_back(self)
    def assign(self, *args): return _pygame.EntityVector_assign(self, *args)
    def resize(self, *args): return _pygame.EntityVector_resize(self, *args)
    def insert(self, *args): return _pygame.EntityVector_insert(self, *args)
    def reserve(self, *args): return _pygame.EntityVector_reserve(self, *args)
    def capacity(self): return _pygame.EntityVector_capacity(self)
    __swig_destroy__ = _pygame.delete_EntityVector
    __del__ = lambda self : None;
EntityVector_swigregister = _pygame.EntityVector_swigregister
EntityVector_swigregister(EntityVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self): return _pygame.StringVector_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _pygame.StringVector___nonzero__(self)
    def __bool__(self): return _pygame.StringVector___bool__(self)
    def __len__(self): return _pygame.StringVector___len__(self)
    def pop(self): return _pygame.StringVector_pop(self)
    def __getslice__(self, *args): return _pygame.StringVector___getslice__(self, *args)
    def __setslice__(self, *args): return _pygame.StringVector___setslice__(self, *args)
    def __delslice__(self, *args): return _pygame.StringVector___delslice__(self, *args)
    def __delitem__(self, *args): return _pygame.StringVector___delitem__(self, *args)
    def __getitem__(self, *args): return _pygame.StringVector___getitem__(self, *args)
    def __setitem__(self, *args): return _pygame.StringVector___setitem__(self, *args)
    def append(self, *args): return _pygame.StringVector_append(self, *args)
    def empty(self): return _pygame.StringVector_empty(self)
    def size(self): return _pygame.StringVector_size(self)
    def clear(self): return _pygame.StringVector_clear(self)
    def swap(self, *args): return _pygame.StringVector_swap(self, *args)
    def get_allocator(self): return _pygame.StringVector_get_allocator(self)
    def begin(self): return _pygame.StringVector_begin(self)
    def end(self): return _pygame.StringVector_end(self)
    def rbegin(self): return _pygame.StringVector_rbegin(self)
    def rend(self): return _pygame.StringVector_rend(self)
    def pop_back(self): return _pygame.StringVector_pop_back(self)
    def erase(self, *args): return _pygame.StringVector_erase(self, *args)
    def __init__(self, *args): 
        this = _pygame.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _pygame.StringVector_push_back(self, *args)
    def front(self): return _pygame.StringVector_front(self)
    def back(self): return _pygame.StringVector_back(self)
    def assign(self, *args): return _pygame.StringVector_assign(self, *args)
    def resize(self, *args): return _pygame.StringVector_resize(self, *args)
    def insert(self, *args): return _pygame.StringVector_insert(self, *args)
    def reserve(self, *args): return _pygame.StringVector_reserve(self, *args)
    def capacity(self): return _pygame.StringVector_capacity(self)
    __swig_destroy__ = _pygame.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _pygame.StringVector_swigregister
StringVector_swigregister(StringVector)


def b2IsValid(*args):
  return _pygame.b2IsValid(*args)
b2IsValid = _pygame.b2IsValid

def b2InvSqrt(*args):
  return _pygame.b2InvSqrt(*args)
b2InvSqrt = _pygame.b2InvSqrt
class b2Vec2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Vec2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Vec2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_b2Vec2(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetZero(self): return _pygame.b2Vec2_SetZero(self)
    def Set(self, *args): return _pygame.b2Vec2_Set(self, *args)
    def __neg__(self): return _pygame.b2Vec2___neg__(self)
    def __call__(self, *args): return _pygame.b2Vec2___call__(self, *args)
    def __iadd__(self, *args): return _pygame.b2Vec2___iadd__(self, *args)
    def __isub__(self, *args): return _pygame.b2Vec2___isub__(self, *args)
    def __imul__(self, *args): return _pygame.b2Vec2___imul__(self, *args)
    def Length(self): return _pygame.b2Vec2_Length(self)
    def LengthSquared(self): return _pygame.b2Vec2_LengthSquared(self)
    def Normalize(self): return _pygame.b2Vec2_Normalize(self)
    def IsValid(self): return _pygame.b2Vec2_IsValid(self)
    __swig_setmethods__["x"] = _pygame.b2Vec2_x_set
    __swig_getmethods__["x"] = _pygame.b2Vec2_x_get
    if _newclass:x = _swig_property(_pygame.b2Vec2_x_get, _pygame.b2Vec2_x_set)
    __swig_setmethods__["y"] = _pygame.b2Vec2_y_set
    __swig_getmethods__["y"] = _pygame.b2Vec2_y_get
    if _newclass:y = _swig_property(_pygame.b2Vec2_y_get, _pygame.b2Vec2_y_set)
    __swig_destroy__ = _pygame.delete_b2Vec2
    __del__ = lambda self : None;
b2Vec2_swigregister = _pygame.b2Vec2_swigregister
b2Vec2_swigregister(b2Vec2)

class b2Vec3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Vec3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Vec3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_b2Vec3(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetZero(self): return _pygame.b2Vec3_SetZero(self)
    def Set(self, *args): return _pygame.b2Vec3_Set(self, *args)
    def __neg__(self): return _pygame.b2Vec3___neg__(self)
    def __iadd__(self, *args): return _pygame.b2Vec3___iadd__(self, *args)
    def __isub__(self, *args): return _pygame.b2Vec3___isub__(self, *args)
    def __imul__(self, *args): return _pygame.b2Vec3___imul__(self, *args)
    __swig_setmethods__["x"] = _pygame.b2Vec3_x_set
    __swig_getmethods__["x"] = _pygame.b2Vec3_x_get
    if _newclass:x = _swig_property(_pygame.b2Vec3_x_get, _pygame.b2Vec3_x_set)
    __swig_setmethods__["y"] = _pygame.b2Vec3_y_set
    __swig_getmethods__["y"] = _pygame.b2Vec3_y_get
    if _newclass:y = _swig_property(_pygame.b2Vec3_y_get, _pygame.b2Vec3_y_set)
    __swig_setmethods__["z"] = _pygame.b2Vec3_z_set
    __swig_getmethods__["z"] = _pygame.b2Vec3_z_get
    if _newclass:z = _swig_property(_pygame.b2Vec3_z_get, _pygame.b2Vec3_z_set)
    __swig_destroy__ = _pygame.delete_b2Vec3
    __del__ = lambda self : None;
b2Vec3_swigregister = _pygame.b2Vec3_swigregister
b2Vec3_swigregister(b2Vec3)

class b2Mat22(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Mat22, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Mat22, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_b2Mat22(*args)
        try: self.this.append(this)
        except: self.this = this
    def Set(self, *args): return _pygame.b2Mat22_Set(self, *args)
    def SetIdentity(self): return _pygame.b2Mat22_SetIdentity(self)
    def SetZero(self): return _pygame.b2Mat22_SetZero(self)
    def GetAngle(self): return _pygame.b2Mat22_GetAngle(self)
    def GetInverse(self): return _pygame.b2Mat22_GetInverse(self)
    def Solve(self, *args): return _pygame.b2Mat22_Solve(self, *args)
    __swig_setmethods__["col1"] = _pygame.b2Mat22_col1_set
    __swig_getmethods__["col1"] = _pygame.b2Mat22_col1_get
    if _newclass:col1 = _swig_property(_pygame.b2Mat22_col1_get, _pygame.b2Mat22_col1_set)
    __swig_setmethods__["col2"] = _pygame.b2Mat22_col2_set
    __swig_getmethods__["col2"] = _pygame.b2Mat22_col2_get
    if _newclass:col2 = _swig_property(_pygame.b2Mat22_col2_get, _pygame.b2Mat22_col2_set)
    __swig_destroy__ = _pygame.delete_b2Mat22
    __del__ = lambda self : None;
b2Mat22_swigregister = _pygame.b2Mat22_swigregister
b2Mat22_swigregister(b2Mat22)

class b2Mat33(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Mat33, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Mat33, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_b2Mat33(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetZero(self): return _pygame.b2Mat33_SetZero(self)
    def Solve33(self, *args): return _pygame.b2Mat33_Solve33(self, *args)
    def Solve22(self, *args): return _pygame.b2Mat33_Solve22(self, *args)
    __swig_setmethods__["col1"] = _pygame.b2Mat33_col1_set
    __swig_getmethods__["col1"] = _pygame.b2Mat33_col1_get
    if _newclass:col1 = _swig_property(_pygame.b2Mat33_col1_get, _pygame.b2Mat33_col1_set)
    __swig_setmethods__["col2"] = _pygame.b2Mat33_col2_set
    __swig_getmethods__["col2"] = _pygame.b2Mat33_col2_get
    if _newclass:col2 = _swig_property(_pygame.b2Mat33_col2_get, _pygame.b2Mat33_col2_set)
    __swig_setmethods__["col3"] = _pygame.b2Mat33_col3_set
    __swig_getmethods__["col3"] = _pygame.b2Mat33_col3_get
    if _newclass:col3 = _swig_property(_pygame.b2Mat33_col3_get, _pygame.b2Mat33_col3_set)
    __swig_destroy__ = _pygame.delete_b2Mat33
    __del__ = lambda self : None;
b2Mat33_swigregister = _pygame.b2Mat33_swigregister
b2Mat33_swigregister(b2Mat33)

class b2Transform(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Transform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Transform, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_b2Transform(*args)
        try: self.this.append(this)
        except: self.this = this
    def SetIdentity(self): return _pygame.b2Transform_SetIdentity(self)
    def Set(self, *args): return _pygame.b2Transform_Set(self, *args)
    def GetAngle(self): return _pygame.b2Transform_GetAngle(self)
    __swig_setmethods__["position"] = _pygame.b2Transform_position_set
    __swig_getmethods__["position"] = _pygame.b2Transform_position_get
    if _newclass:position = _swig_property(_pygame.b2Transform_position_get, _pygame.b2Transform_position_set)
    __swig_setmethods__["R"] = _pygame.b2Transform_R_set
    __swig_getmethods__["R"] = _pygame.b2Transform_R_get
    if _newclass:R = _swig_property(_pygame.b2Transform_R_get, _pygame.b2Transform_R_set)
    __swig_destroy__ = _pygame.delete_b2Transform
    __del__ = lambda self : None;
b2Transform_swigregister = _pygame.b2Transform_swigregister
b2Transform_swigregister(b2Transform)

class b2Sweep(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Sweep, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Sweep, name)
    __repr__ = _swig_repr
    def GetTransform(self, *args): return _pygame.b2Sweep_GetTransform(self, *args)
    def Advance(self, *args): return _pygame.b2Sweep_Advance(self, *args)
    def Normalize(self): return _pygame.b2Sweep_Normalize(self)
    __swig_setmethods__["localCenter"] = _pygame.b2Sweep_localCenter_set
    __swig_getmethods__["localCenter"] = _pygame.b2Sweep_localCenter_get
    if _newclass:localCenter = _swig_property(_pygame.b2Sweep_localCenter_get, _pygame.b2Sweep_localCenter_set)
    __swig_setmethods__["c0"] = _pygame.b2Sweep_c0_set
    __swig_getmethods__["c0"] = _pygame.b2Sweep_c0_get
    if _newclass:c0 = _swig_property(_pygame.b2Sweep_c0_get, _pygame.b2Sweep_c0_set)
    __swig_setmethods__["c"] = _pygame.b2Sweep_c_set
    __swig_getmethods__["c"] = _pygame.b2Sweep_c_get
    if _newclass:c = _swig_property(_pygame.b2Sweep_c_get, _pygame.b2Sweep_c_set)
    __swig_setmethods__["a0"] = _pygame.b2Sweep_a0_set
    __swig_getmethods__["a0"] = _pygame.b2Sweep_a0_get
    if _newclass:a0 = _swig_property(_pygame.b2Sweep_a0_get, _pygame.b2Sweep_a0_set)
    __swig_setmethods__["a"] = _pygame.b2Sweep_a_set
    __swig_getmethods__["a"] = _pygame.b2Sweep_a_get
    if _newclass:a = _swig_property(_pygame.b2Sweep_a_get, _pygame.b2Sweep_a_set)
    def __init__(self): 
        this = _pygame.new_b2Sweep()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_b2Sweep
    __del__ = lambda self : None;
b2Sweep_swigregister = _pygame.b2Sweep_swigregister
b2Sweep_swigregister(b2Sweep)


def b2Distance(*args):
  return _pygame.b2Distance(*args)
b2Distance = _pygame.b2Distance

def b2DistanceSquared(*args):
  return _pygame.b2DistanceSquared(*args)
b2DistanceSquared = _pygame.b2DistanceSquared

def b2Min(*args):
  return _pygame.b2Min(*args)
b2Min = _pygame.b2Min

def b2Max(*args):
  return _pygame.b2Max(*args)
b2Max = _pygame.b2Max

def b2Clamp(*args):
  return _pygame.b2Clamp(*args)
b2Clamp = _pygame.b2Clamp

def b2NextPowerOfTwo(*args):
  return _pygame.b2NextPowerOfTwo(*args)
b2NextPowerOfTwo = _pygame.b2NextPowerOfTwo

def b2IsPowerOfTwo(*args):
  return _pygame.b2IsPowerOfTwo(*args)
b2IsPowerOfTwo = _pygame.b2IsPowerOfTwo
b2_staticBody = _pygame.b2_staticBody
b2_kinematicBody = _pygame.b2_kinematicBody
b2_dynamicBody = _pygame.b2_dynamicBody
class b2BodyDef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2BodyDef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2BodyDef, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_b2BodyDef()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["type"] = _pygame.b2BodyDef_type_set
    __swig_getmethods__["type"] = _pygame.b2BodyDef_type_get
    if _newclass:type = _swig_property(_pygame.b2BodyDef_type_get, _pygame.b2BodyDef_type_set)
    __swig_setmethods__["position"] = _pygame.b2BodyDef_position_set
    __swig_getmethods__["position"] = _pygame.b2BodyDef_position_get
    if _newclass:position = _swig_property(_pygame.b2BodyDef_position_get, _pygame.b2BodyDef_position_set)
    __swig_setmethods__["angle"] = _pygame.b2BodyDef_angle_set
    __swig_getmethods__["angle"] = _pygame.b2BodyDef_angle_get
    if _newclass:angle = _swig_property(_pygame.b2BodyDef_angle_get, _pygame.b2BodyDef_angle_set)
    __swig_setmethods__["linearVelocity"] = _pygame.b2BodyDef_linearVelocity_set
    __swig_getmethods__["linearVelocity"] = _pygame.b2BodyDef_linearVelocity_get
    if _newclass:linearVelocity = _swig_property(_pygame.b2BodyDef_linearVelocity_get, _pygame.b2BodyDef_linearVelocity_set)
    __swig_setmethods__["angularVelocity"] = _pygame.b2BodyDef_angularVelocity_set
    __swig_getmethods__["angularVelocity"] = _pygame.b2BodyDef_angularVelocity_get
    if _newclass:angularVelocity = _swig_property(_pygame.b2BodyDef_angularVelocity_get, _pygame.b2BodyDef_angularVelocity_set)
    __swig_setmethods__["linearDamping"] = _pygame.b2BodyDef_linearDamping_set
    __swig_getmethods__["linearDamping"] = _pygame.b2BodyDef_linearDamping_get
    if _newclass:linearDamping = _swig_property(_pygame.b2BodyDef_linearDamping_get, _pygame.b2BodyDef_linearDamping_set)
    __swig_setmethods__["angularDamping"] = _pygame.b2BodyDef_angularDamping_set
    __swig_getmethods__["angularDamping"] = _pygame.b2BodyDef_angularDamping_get
    if _newclass:angularDamping = _swig_property(_pygame.b2BodyDef_angularDamping_get, _pygame.b2BodyDef_angularDamping_set)
    __swig_setmethods__["allowSleep"] = _pygame.b2BodyDef_allowSleep_set
    __swig_getmethods__["allowSleep"] = _pygame.b2BodyDef_allowSleep_get
    if _newclass:allowSleep = _swig_property(_pygame.b2BodyDef_allowSleep_get, _pygame.b2BodyDef_allowSleep_set)
    __swig_setmethods__["awake"] = _pygame.b2BodyDef_awake_set
    __swig_getmethods__["awake"] = _pygame.b2BodyDef_awake_get
    if _newclass:awake = _swig_property(_pygame.b2BodyDef_awake_get, _pygame.b2BodyDef_awake_set)
    __swig_setmethods__["fixedRotation"] = _pygame.b2BodyDef_fixedRotation_set
    __swig_getmethods__["fixedRotation"] = _pygame.b2BodyDef_fixedRotation_get
    if _newclass:fixedRotation = _swig_property(_pygame.b2BodyDef_fixedRotation_get, _pygame.b2BodyDef_fixedRotation_set)
    __swig_setmethods__["bullet"] = _pygame.b2BodyDef_bullet_set
    __swig_getmethods__["bullet"] = _pygame.b2BodyDef_bullet_get
    if _newclass:bullet = _swig_property(_pygame.b2BodyDef_bullet_get, _pygame.b2BodyDef_bullet_set)
    __swig_setmethods__["active"] = _pygame.b2BodyDef_active_set
    __swig_getmethods__["active"] = _pygame.b2BodyDef_active_get
    if _newclass:active = _swig_property(_pygame.b2BodyDef_active_get, _pygame.b2BodyDef_active_set)
    __swig_setmethods__["userData"] = _pygame.b2BodyDef_userData_set
    __swig_getmethods__["userData"] = _pygame.b2BodyDef_userData_get
    if _newclass:userData = _swig_property(_pygame.b2BodyDef_userData_get, _pygame.b2BodyDef_userData_set)
    __swig_setmethods__["inertiaScale"] = _pygame.b2BodyDef_inertiaScale_set
    __swig_getmethods__["inertiaScale"] = _pygame.b2BodyDef_inertiaScale_get
    if _newclass:inertiaScale = _swig_property(_pygame.b2BodyDef_inertiaScale_get, _pygame.b2BodyDef_inertiaScale_set)
    __swig_destroy__ = _pygame.delete_b2BodyDef
    __del__ = lambda self : None;
b2BodyDef_swigregister = _pygame.b2BodyDef_swigregister
b2BodyDef_swigregister(b2BodyDef)
cvar = _pygame.cvar
b2Vec2_zero = cvar.b2Vec2_zero
b2Mat22_identity = cvar.b2Mat22_identity
b2Transform_identity = cvar.b2Transform_identity

def b2Dot(*args):
  return _pygame.b2Dot(*args)
b2Dot = _pygame.b2Dot

def b2Cross(*args):
  return _pygame.b2Cross(*args)
b2Cross = _pygame.b2Cross

def b2Mul(*args):
  return _pygame.b2Mul(*args)
b2Mul = _pygame.b2Mul

def b2MulT(*args):
  return _pygame.b2MulT(*args)
b2MulT = _pygame.b2MulT

def b2Abs(*args):
  return _pygame.b2Abs(*args)
b2Abs = _pygame.b2Abs

class b2Body(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, b2Body, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, b2Body, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def CreateFixture(self, *args): return _pygame.b2Body_CreateFixture(self, *args)
    def DestroyFixture(self, *args): return _pygame.b2Body_DestroyFixture(self, *args)
    def SetTransform(self, *args): return _pygame.b2Body_SetTransform(self, *args)
    def GetTransform(self): return _pygame.b2Body_GetTransform(self)
    def GetPosition(self): return _pygame.b2Body_GetPosition(self)
    def GetAngle(self): return _pygame.b2Body_GetAngle(self)
    def GetWorldCenter(self): return _pygame.b2Body_GetWorldCenter(self)
    def GetLocalCenter(self): return _pygame.b2Body_GetLocalCenter(self)
    def SetLinearVelocity(self, *args): return _pygame.b2Body_SetLinearVelocity(self, *args)
    def GetLinearVelocity(self): return _pygame.b2Body_GetLinearVelocity(self)
    def SetAngularVelocity(self, *args): return _pygame.b2Body_SetAngularVelocity(self, *args)
    def GetAngularVelocity(self): return _pygame.b2Body_GetAngularVelocity(self)
    def ApplyForce(self, *args): return _pygame.b2Body_ApplyForce(self, *args)
    def ApplyTorque(self, *args): return _pygame.b2Body_ApplyTorque(self, *args)
    def ApplyLinearImpulse(self, *args): return _pygame.b2Body_ApplyLinearImpulse(self, *args)
    def ApplyAngularImpulse(self, *args): return _pygame.b2Body_ApplyAngularImpulse(self, *args)
    def GetMass(self): return _pygame.b2Body_GetMass(self)
    def GetInertia(self): return _pygame.b2Body_GetInertia(self)
    def GetMassData(self, *args): return _pygame.b2Body_GetMassData(self, *args)
    def SetMassData(self, *args): return _pygame.b2Body_SetMassData(self, *args)
    def ResetMassData(self): return _pygame.b2Body_ResetMassData(self)
    def GetWorldPoint(self, *args): return _pygame.b2Body_GetWorldPoint(self, *args)
    def GetWorldVector(self, *args): return _pygame.b2Body_GetWorldVector(self, *args)
    def GetLocalPoint(self, *args): return _pygame.b2Body_GetLocalPoint(self, *args)
    def GetLocalVector(self, *args): return _pygame.b2Body_GetLocalVector(self, *args)
    def GetLinearVelocityFromWorldPoint(self, *args): return _pygame.b2Body_GetLinearVelocityFromWorldPoint(self, *args)
    def GetLinearVelocityFromLocalPoint(self, *args): return _pygame.b2Body_GetLinearVelocityFromLocalPoint(self, *args)
    def GetLinearDamping(self): return _pygame.b2Body_GetLinearDamping(self)
    def SetLinearDamping(self, *args): return _pygame.b2Body_SetLinearDamping(self, *args)
    def GetAngularDamping(self): return _pygame.b2Body_GetAngularDamping(self)
    def SetAngularDamping(self, *args): return _pygame.b2Body_SetAngularDamping(self, *args)
    def SetType(self, *args): return _pygame.b2Body_SetType(self, *args)
    def GetType(self): return _pygame.b2Body_GetType(self)
    def SetBullet(self, *args): return _pygame.b2Body_SetBullet(self, *args)
    def IsBullet(self): return _pygame.b2Body_IsBullet(self)
    def SetSleepingAllowed(self, *args): return _pygame.b2Body_SetSleepingAllowed(self, *args)
    def IsSleepingAllowed(self): return _pygame.b2Body_IsSleepingAllowed(self)
    def SetAwake(self, *args): return _pygame.b2Body_SetAwake(self, *args)
    def IsAwake(self): return _pygame.b2Body_IsAwake(self)
    def SetActive(self, *args): return _pygame.b2Body_SetActive(self, *args)
    def IsActive(self): return _pygame.b2Body_IsActive(self)
    def SetFixedRotation(self, *args): return _pygame.b2Body_SetFixedRotation(self, *args)
    def IsFixedRotation(self): return _pygame.b2Body_IsFixedRotation(self)
    def GetFixtureList(self, *args): return _pygame.b2Body_GetFixtureList(self, *args)
    def GetJointList(self, *args): return _pygame.b2Body_GetJointList(self, *args)
    def GetContactList(self, *args): return _pygame.b2Body_GetContactList(self, *args)
    def GetNext(self, *args): return _pygame.b2Body_GetNext(self, *args)
    def GetUserData(self): return _pygame.b2Body_GetUserData(self)
    def SetUserData(self, *args): return _pygame.b2Body_SetUserData(self, *args)
    def GetWorld(self, *args): return _pygame.b2Body_GetWorld(self, *args)
b2Body_swigregister = _pygame.b2Body_swigregister
b2Body_swigregister(b2Body)

class SDL_KeyboardEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SDL_KeyboardEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SDL_KeyboardEvent, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _pygame.SDL_KeyboardEvent_type_set
    __swig_getmethods__["type"] = _pygame.SDL_KeyboardEvent_type_get
    if _newclass:type = _swig_property(_pygame.SDL_KeyboardEvent_type_get, _pygame.SDL_KeyboardEvent_type_set)
    __swig_setmethods__["which"] = _pygame.SDL_KeyboardEvent_which_set
    __swig_getmethods__["which"] = _pygame.SDL_KeyboardEvent_which_get
    if _newclass:which = _swig_property(_pygame.SDL_KeyboardEvent_which_get, _pygame.SDL_KeyboardEvent_which_set)
    __swig_setmethods__["state"] = _pygame.SDL_KeyboardEvent_state_set
    __swig_getmethods__["state"] = _pygame.SDL_KeyboardEvent_state_get
    if _newclass:state = _swig_property(_pygame.SDL_KeyboardEvent_state_get, _pygame.SDL_KeyboardEvent_state_set)
    __swig_setmethods__["keysym"] = _pygame.SDL_KeyboardEvent_keysym_set
    __swig_getmethods__["keysym"] = _pygame.SDL_KeyboardEvent_keysym_get
    if _newclass:keysym = _swig_property(_pygame.SDL_KeyboardEvent_keysym_get, _pygame.SDL_KeyboardEvent_keysym_set)
    def __init__(self): 
        this = _pygame.new_SDL_KeyboardEvent()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_SDL_KeyboardEvent
    __del__ = lambda self : None;
SDL_KeyboardEvent_swigregister = _pygame.SDL_KeyboardEvent_swigregister
SDL_KeyboardEvent_swigregister(SDL_KeyboardEvent)

SDLK_UNKNOWN = _pygame.SDLK_UNKNOWN
SDLK_FIRST = _pygame.SDLK_FIRST
SDLK_BACKSPACE = _pygame.SDLK_BACKSPACE
SDLK_TAB = _pygame.SDLK_TAB
SDLK_CLEAR = _pygame.SDLK_CLEAR
SDLK_RETURN = _pygame.SDLK_RETURN
SDLK_PAUSE = _pygame.SDLK_PAUSE
SDLK_ESCAPE = _pygame.SDLK_ESCAPE
SDLK_SPACE = _pygame.SDLK_SPACE
SDLK_EXCLAIM = _pygame.SDLK_EXCLAIM
SDLK_QUOTEDBL = _pygame.SDLK_QUOTEDBL
SDLK_HASH = _pygame.SDLK_HASH
SDLK_DOLLAR = _pygame.SDLK_DOLLAR
SDLK_AMPERSAND = _pygame.SDLK_AMPERSAND
SDLK_QUOTE = _pygame.SDLK_QUOTE
SDLK_LEFTPAREN = _pygame.SDLK_LEFTPAREN
SDLK_RIGHTPAREN = _pygame.SDLK_RIGHTPAREN
SDLK_ASTERISK = _pygame.SDLK_ASTERISK
SDLK_PLUS = _pygame.SDLK_PLUS
SDLK_COMMA = _pygame.SDLK_COMMA
SDLK_MINUS = _pygame.SDLK_MINUS
SDLK_PERIOD = _pygame.SDLK_PERIOD
SDLK_SLASH = _pygame.SDLK_SLASH
SDLK_0 = _pygame.SDLK_0
SDLK_1 = _pygame.SDLK_1
SDLK_2 = _pygame.SDLK_2
SDLK_3 = _pygame.SDLK_3
SDLK_4 = _pygame.SDLK_4
SDLK_5 = _pygame.SDLK_5
SDLK_6 = _pygame.SDLK_6
SDLK_7 = _pygame.SDLK_7
SDLK_8 = _pygame.SDLK_8
SDLK_9 = _pygame.SDLK_9
SDLK_COLON = _pygame.SDLK_COLON
SDLK_SEMICOLON = _pygame.SDLK_SEMICOLON
SDLK_LESS = _pygame.SDLK_LESS
SDLK_EQUALS = _pygame.SDLK_EQUALS
SDLK_GREATER = _pygame.SDLK_GREATER
SDLK_QUESTION = _pygame.SDLK_QUESTION
SDLK_AT = _pygame.SDLK_AT
SDLK_LEFTBRACKET = _pygame.SDLK_LEFTBRACKET
SDLK_BACKSLASH = _pygame.SDLK_BACKSLASH
SDLK_RIGHTBRACKET = _pygame.SDLK_RIGHTBRACKET
SDLK_CARET = _pygame.SDLK_CARET
SDLK_UNDERSCORE = _pygame.SDLK_UNDERSCORE
SDLK_BACKQUOTE = _pygame.SDLK_BACKQUOTE
SDLK_a = _pygame.SDLK_a
SDLK_b = _pygame.SDLK_b
SDLK_c = _pygame.SDLK_c
SDLK_d = _pygame.SDLK_d
SDLK_e = _pygame.SDLK_e
SDLK_f = _pygame.SDLK_f
SDLK_g = _pygame.SDLK_g
SDLK_h = _pygame.SDLK_h
SDLK_i = _pygame.SDLK_i
SDLK_j = _pygame.SDLK_j
SDLK_k = _pygame.SDLK_k
SDLK_l = _pygame.SDLK_l
SDLK_m = _pygame.SDLK_m
SDLK_n = _pygame.SDLK_n
SDLK_o = _pygame.SDLK_o
SDLK_p = _pygame.SDLK_p
SDLK_q = _pygame.SDLK_q
SDLK_r = _pygame.SDLK_r
SDLK_s = _pygame.SDLK_s
SDLK_t = _pygame.SDLK_t
SDLK_u = _pygame.SDLK_u
SDLK_v = _pygame.SDLK_v
SDLK_w = _pygame.SDLK_w
SDLK_x = _pygame.SDLK_x
SDLK_y = _pygame.SDLK_y
SDLK_z = _pygame.SDLK_z
SDLK_DELETE = _pygame.SDLK_DELETE
SDLK_WORLD_0 = _pygame.SDLK_WORLD_0
SDLK_WORLD_1 = _pygame.SDLK_WORLD_1
SDLK_WORLD_2 = _pygame.SDLK_WORLD_2
SDLK_WORLD_3 = _pygame.SDLK_WORLD_3
SDLK_WORLD_4 = _pygame.SDLK_WORLD_4
SDLK_WORLD_5 = _pygame.SDLK_WORLD_5
SDLK_WORLD_6 = _pygame.SDLK_WORLD_6
SDLK_WORLD_7 = _pygame.SDLK_WORLD_7
SDLK_WORLD_8 = _pygame.SDLK_WORLD_8
SDLK_WORLD_9 = _pygame.SDLK_WORLD_9
SDLK_WORLD_10 = _pygame.SDLK_WORLD_10
SDLK_WORLD_11 = _pygame.SDLK_WORLD_11
SDLK_WORLD_12 = _pygame.SDLK_WORLD_12
SDLK_WORLD_13 = _pygame.SDLK_WORLD_13
SDLK_WORLD_14 = _pygame.SDLK_WORLD_14
SDLK_WORLD_15 = _pygame.SDLK_WORLD_15
SDLK_WORLD_16 = _pygame.SDLK_WORLD_16
SDLK_WORLD_17 = _pygame.SDLK_WORLD_17
SDLK_WORLD_18 = _pygame.SDLK_WORLD_18
SDLK_WORLD_19 = _pygame.SDLK_WORLD_19
SDLK_WORLD_20 = _pygame.SDLK_WORLD_20
SDLK_WORLD_21 = _pygame.SDLK_WORLD_21
SDLK_WORLD_22 = _pygame.SDLK_WORLD_22
SDLK_WORLD_23 = _pygame.SDLK_WORLD_23
SDLK_WORLD_24 = _pygame.SDLK_WORLD_24
SDLK_WORLD_25 = _pygame.SDLK_WORLD_25
SDLK_WORLD_26 = _pygame.SDLK_WORLD_26
SDLK_WORLD_27 = _pygame.SDLK_WORLD_27
SDLK_WORLD_28 = _pygame.SDLK_WORLD_28
SDLK_WORLD_29 = _pygame.SDLK_WORLD_29
SDLK_WORLD_30 = _pygame.SDLK_WORLD_30
SDLK_WORLD_31 = _pygame.SDLK_WORLD_31
SDLK_WORLD_32 = _pygame.SDLK_WORLD_32
SDLK_WORLD_33 = _pygame.SDLK_WORLD_33
SDLK_WORLD_34 = _pygame.SDLK_WORLD_34
SDLK_WORLD_35 = _pygame.SDLK_WORLD_35
SDLK_WORLD_36 = _pygame.SDLK_WORLD_36
SDLK_WORLD_37 = _pygame.SDLK_WORLD_37
SDLK_WORLD_38 = _pygame.SDLK_WORLD_38
SDLK_WORLD_39 = _pygame.SDLK_WORLD_39
SDLK_WORLD_40 = _pygame.SDLK_WORLD_40
SDLK_WORLD_41 = _pygame.SDLK_WORLD_41
SDLK_WORLD_42 = _pygame.SDLK_WORLD_42
SDLK_WORLD_43 = _pygame.SDLK_WORLD_43
SDLK_WORLD_44 = _pygame.SDLK_WORLD_44
SDLK_WORLD_45 = _pygame.SDLK_WORLD_45
SDLK_WORLD_46 = _pygame.SDLK_WORLD_46
SDLK_WORLD_47 = _pygame.SDLK_WORLD_47
SDLK_WORLD_48 = _pygame.SDLK_WORLD_48
SDLK_WORLD_49 = _pygame.SDLK_WORLD_49
SDLK_WORLD_50 = _pygame.SDLK_WORLD_50
SDLK_WORLD_51 = _pygame.SDLK_WORLD_51
SDLK_WORLD_52 = _pygame.SDLK_WORLD_52
SDLK_WORLD_53 = _pygame.SDLK_WORLD_53
SDLK_WORLD_54 = _pygame.SDLK_WORLD_54
SDLK_WORLD_55 = _pygame.SDLK_WORLD_55
SDLK_WORLD_56 = _pygame.SDLK_WORLD_56
SDLK_WORLD_57 = _pygame.SDLK_WORLD_57
SDLK_WORLD_58 = _pygame.SDLK_WORLD_58
SDLK_WORLD_59 = _pygame.SDLK_WORLD_59
SDLK_WORLD_60 = _pygame.SDLK_WORLD_60
SDLK_WORLD_61 = _pygame.SDLK_WORLD_61
SDLK_WORLD_62 = _pygame.SDLK_WORLD_62
SDLK_WORLD_63 = _pygame.SDLK_WORLD_63
SDLK_WORLD_64 = _pygame.SDLK_WORLD_64
SDLK_WORLD_65 = _pygame.SDLK_WORLD_65
SDLK_WORLD_66 = _pygame.SDLK_WORLD_66
SDLK_WORLD_67 = _pygame.SDLK_WORLD_67
SDLK_WORLD_68 = _pygame.SDLK_WORLD_68
SDLK_WORLD_69 = _pygame.SDLK_WORLD_69
SDLK_WORLD_70 = _pygame.SDLK_WORLD_70
SDLK_WORLD_71 = _pygame.SDLK_WORLD_71
SDLK_WORLD_72 = _pygame.SDLK_WORLD_72
SDLK_WORLD_73 = _pygame.SDLK_WORLD_73
SDLK_WORLD_74 = _pygame.SDLK_WORLD_74
SDLK_WORLD_75 = _pygame.SDLK_WORLD_75
SDLK_WORLD_76 = _pygame.SDLK_WORLD_76
SDLK_WORLD_77 = _pygame.SDLK_WORLD_77
SDLK_WORLD_78 = _pygame.SDLK_WORLD_78
SDLK_WORLD_79 = _pygame.SDLK_WORLD_79
SDLK_WORLD_80 = _pygame.SDLK_WORLD_80
SDLK_WORLD_81 = _pygame.SDLK_WORLD_81
SDLK_WORLD_82 = _pygame.SDLK_WORLD_82
SDLK_WORLD_83 = _pygame.SDLK_WORLD_83
SDLK_WORLD_84 = _pygame.SDLK_WORLD_84
SDLK_WORLD_85 = _pygame.SDLK_WORLD_85
SDLK_WORLD_86 = _pygame.SDLK_WORLD_86
SDLK_WORLD_87 = _pygame.SDLK_WORLD_87
SDLK_WORLD_88 = _pygame.SDLK_WORLD_88
SDLK_WORLD_89 = _pygame.SDLK_WORLD_89
SDLK_WORLD_90 = _pygame.SDLK_WORLD_90
SDLK_WORLD_91 = _pygame.SDLK_WORLD_91
SDLK_WORLD_92 = _pygame.SDLK_WORLD_92
SDLK_WORLD_93 = _pygame.SDLK_WORLD_93
SDLK_WORLD_94 = _pygame.SDLK_WORLD_94
SDLK_WORLD_95 = _pygame.SDLK_WORLD_95
SDLK_KP0 = _pygame.SDLK_KP0
SDLK_KP1 = _pygame.SDLK_KP1
SDLK_KP2 = _pygame.SDLK_KP2
SDLK_KP3 = _pygame.SDLK_KP3
SDLK_KP4 = _pygame.SDLK_KP4
SDLK_KP5 = _pygame.SDLK_KP5
SDLK_KP6 = _pygame.SDLK_KP6
SDLK_KP7 = _pygame.SDLK_KP7
SDLK_KP8 = _pygame.SDLK_KP8
SDLK_KP9 = _pygame.SDLK_KP9
SDLK_KP_PERIOD = _pygame.SDLK_KP_PERIOD
SDLK_KP_DIVIDE = _pygame.SDLK_KP_DIVIDE
SDLK_KP_MULTIPLY = _pygame.SDLK_KP_MULTIPLY
SDLK_KP_MINUS = _pygame.SDLK_KP_MINUS
SDLK_KP_PLUS = _pygame.SDLK_KP_PLUS
SDLK_KP_ENTER = _pygame.SDLK_KP_ENTER
SDLK_KP_EQUALS = _pygame.SDLK_KP_EQUALS
SDLK_UP = _pygame.SDLK_UP
SDLK_DOWN = _pygame.SDLK_DOWN
SDLK_RIGHT = _pygame.SDLK_RIGHT
SDLK_LEFT = _pygame.SDLK_LEFT
SDLK_INSERT = _pygame.SDLK_INSERT
SDLK_HOME = _pygame.SDLK_HOME
SDLK_END = _pygame.SDLK_END
SDLK_PAGEUP = _pygame.SDLK_PAGEUP
SDLK_PAGEDOWN = _pygame.SDLK_PAGEDOWN
SDLK_F1 = _pygame.SDLK_F1
SDLK_F2 = _pygame.SDLK_F2
SDLK_F3 = _pygame.SDLK_F3
SDLK_F4 = _pygame.SDLK_F4
SDLK_F5 = _pygame.SDLK_F5
SDLK_F6 = _pygame.SDLK_F6
SDLK_F7 = _pygame.SDLK_F7
SDLK_F8 = _pygame.SDLK_F8
SDLK_F9 = _pygame.SDLK_F9
SDLK_F10 = _pygame.SDLK_F10
SDLK_F11 = _pygame.SDLK_F11
SDLK_F12 = _pygame.SDLK_F12
SDLK_F13 = _pygame.SDLK_F13
SDLK_F14 = _pygame.SDLK_F14
SDLK_F15 = _pygame.SDLK_F15
SDLK_NUMLOCK = _pygame.SDLK_NUMLOCK
SDLK_CAPSLOCK = _pygame.SDLK_CAPSLOCK
SDLK_SCROLLOCK = _pygame.SDLK_SCROLLOCK
SDLK_RSHIFT = _pygame.SDLK_RSHIFT
SDLK_LSHIFT = _pygame.SDLK_LSHIFT
SDLK_RCTRL = _pygame.SDLK_RCTRL
SDLK_LCTRL = _pygame.SDLK_LCTRL
SDLK_RALT = _pygame.SDLK_RALT
SDLK_LALT = _pygame.SDLK_LALT
SDLK_RMETA = _pygame.SDLK_RMETA
SDLK_LMETA = _pygame.SDLK_LMETA
SDLK_LSUPER = _pygame.SDLK_LSUPER
SDLK_RSUPER = _pygame.SDLK_RSUPER
SDLK_MODE = _pygame.SDLK_MODE
SDLK_COMPOSE = _pygame.SDLK_COMPOSE
SDLK_HELP = _pygame.SDLK_HELP
SDLK_PRINT = _pygame.SDLK_PRINT
SDLK_SYSREQ = _pygame.SDLK_SYSREQ
SDLK_BREAK = _pygame.SDLK_BREAK
SDLK_MENU = _pygame.SDLK_MENU
SDLK_POWER = _pygame.SDLK_POWER
SDLK_EURO = _pygame.SDLK_EURO
SDLK_UNDO = _pygame.SDLK_UNDO
SDLK_LAST = _pygame.SDLK_LAST
KMOD_NONE = _pygame.KMOD_NONE
KMOD_LSHIFT = _pygame.KMOD_LSHIFT
KMOD_RSHIFT = _pygame.KMOD_RSHIFT
KMOD_LCTRL = _pygame.KMOD_LCTRL
KMOD_RCTRL = _pygame.KMOD_RCTRL
KMOD_LALT = _pygame.KMOD_LALT
KMOD_RALT = _pygame.KMOD_RALT
KMOD_LMETA = _pygame.KMOD_LMETA
KMOD_RMETA = _pygame.KMOD_RMETA
KMOD_NUM = _pygame.KMOD_NUM
KMOD_CAPS = _pygame.KMOD_CAPS
KMOD_MODE = _pygame.KMOD_MODE
KMOD_RESERVED = _pygame.KMOD_RESERVED
class Color(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Color, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Color, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_Color(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["RGB"] = lambda x: _pygame.Color_RGB
    if _newclass:RGB = staticmethod(_pygame.Color_RGB)
    __swig_getmethods__["RGBA"] = lambda x: _pygame.Color_RGBA
    if _newclass:RGBA = staticmethod(_pygame.Color_RGBA)
    __swig_getmethods__["Random"] = lambda x: _pygame.Color_Random
    if _newclass:Random = staticmethod(_pygame.Color_Random)
    def Clamp(self): return _pygame.Color_Clamp(self)
    def Intensity(self): return _pygame.Color_Intensity(self)
    def __ne__(self, *args): return _pygame.Color___ne__(self, *args)
    def Load(self, *args): return _pygame.Color_Load(self, *args)
    def Save(self, *args): return _pygame.Color_Save(self, *args)
    __swig_setmethods__["r"] = _pygame.Color_r_set
    __swig_getmethods__["r"] = _pygame.Color_r_get
    if _newclass:r = _swig_property(_pygame.Color_r_get, _pygame.Color_r_set)
    __swig_setmethods__["g"] = _pygame.Color_g_set
    __swig_getmethods__["g"] = _pygame.Color_g_get
    if _newclass:g = _swig_property(_pygame.Color_g_get, _pygame.Color_g_set)
    __swig_setmethods__["b"] = _pygame.Color_b_set
    __swig_getmethods__["b"] = _pygame.Color_b_get
    if _newclass:b = _swig_property(_pygame.Color_b_get, _pygame.Color_b_set)
    __swig_setmethods__["a"] = _pygame.Color_a_set
    __swig_getmethods__["a"] = _pygame.Color_a_get
    if _newclass:a = _swig_property(_pygame.Color_a_get, _pygame.Color_a_set)
    __swig_setmethods__["white"] = _pygame.Color_white_set
    __swig_getmethods__["white"] = _pygame.Color_white_get
    if _newclass:white = _swig_property(_pygame.Color_white_get, _pygame.Color_white_set)
    __swig_setmethods__["grey"] = _pygame.Color_grey_set
    __swig_getmethods__["grey"] = _pygame.Color_grey_get
    if _newclass:grey = _swig_property(_pygame.Color_grey_get, _pygame.Color_grey_set)
    __swig_setmethods__["black"] = _pygame.Color_black_set
    __swig_getmethods__["black"] = _pygame.Color_black_get
    if _newclass:black = _swig_property(_pygame.Color_black_get, _pygame.Color_black_set)
    __swig_setmethods__["red"] = _pygame.Color_red_set
    __swig_getmethods__["red"] = _pygame.Color_red_get
    if _newclass:red = _swig_property(_pygame.Color_red_get, _pygame.Color_red_set)
    __swig_setmethods__["green"] = _pygame.Color_green_set
    __swig_getmethods__["green"] = _pygame.Color_green_get
    if _newclass:green = _swig_property(_pygame.Color_green_get, _pygame.Color_green_set)
    __swig_setmethods__["blue"] = _pygame.Color_blue_set
    __swig_getmethods__["blue"] = _pygame.Color_blue_get
    if _newclass:blue = _swig_property(_pygame.Color_blue_get, _pygame.Color_blue_set)
    __swig_setmethods__["yellow"] = _pygame.Color_yellow_set
    __swig_getmethods__["yellow"] = _pygame.Color_yellow_get
    if _newclass:yellow = _swig_property(_pygame.Color_yellow_get, _pygame.Color_yellow_set)
    __swig_setmethods__["orange"] = _pygame.Color_orange_set
    __swig_getmethods__["orange"] = _pygame.Color_orange_get
    if _newclass:orange = _swig_property(_pygame.Color_orange_get, _pygame.Color_orange_set)
    __swig_setmethods__["purple"] = _pygame.Color_purple_set
    __swig_getmethods__["purple"] = _pygame.Color_purple_get
    if _newclass:purple = _swig_property(_pygame.Color_purple_get, _pygame.Color_purple_set)
    __swig_destroy__ = _pygame.delete_Color
    __del__ = lambda self : None;
Color_swigregister = _pygame.Color_swigregister
Color_swigregister(Color)

def Color_RGB(*args):
  return _pygame.Color_RGB(*args)
Color_RGB = _pygame.Color_RGB

def Color_RGBA(*args):
  return _pygame.Color_RGBA(*args)
Color_RGBA = _pygame.Color_RGBA

def Color_Random():
  return _pygame.Color_Random()
Color_Random = _pygame.Color_Random


def __add__(*args):
  return _pygame.__add__(*args)
__add__ = _pygame.__add__

def __sub__(*args):
  return _pygame.__sub__(*args)
__sub__ = _pygame.__sub__
INFINITY = _pygame.INFINITY

def RoundToNearest(*args):
  return _pygame.RoundToNearest(*args)
RoundToNearest = _pygame.RoundToNearest
class Random(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Random, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Random, name)
    __repr__ = _swig_repr
    __swig_getmethods__["Seed"] = lambda x: _pygame.Random_Seed
    if _newclass:Seed = staticmethod(_pygame.Random_Seed)
    __swig_getmethods__["Range"] = lambda x: _pygame.Random_Range
    if _newclass:Range = staticmethod(_pygame.Random_Range)
    __swig_getmethods__["Percent"] = lambda x: _pygame.Random_Percent
    if _newclass:Percent = staticmethod(_pygame.Random_Percent)
    __swig_getmethods__["CoinFlip"] = lambda x: _pygame.Random_CoinFlip
    if _newclass:CoinFlip = staticmethod(_pygame.Random_CoinFlip)
    __swig_getmethods__["RangeFloat"] = lambda x: _pygame.Random_RangeFloat
    if _newclass:RangeFloat = staticmethod(_pygame.Random_RangeFloat)
    def __init__(self): 
        this = _pygame.new_Random()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Random
    __del__ = lambda self : None;
Random_swigregister = _pygame.Random_swigregister
Random_swigregister(Random)
PI = cvar.PI
E = cvar.E
DEG2RAD = cvar.DEG2RAD
RAD2DEG = cvar.RAD2DEG

def Random_Seed(*args):
  return _pygame.Random_Seed(*args)
Random_Seed = _pygame.Random_Seed

def Random_Range(*args):
  return _pygame.Random_Range(*args)
Random_Range = _pygame.Random_Range

def Random_Percent():
  return _pygame.Random_Percent()
Random_Percent = _pygame.Random_Percent

def Random_CoinFlip():
  return _pygame.Random_CoinFlip()
Random_CoinFlip = _pygame.Random_CoinFlip

def Random_RangeFloat(*args):
  return _pygame.Random_RangeFloat(*args)
Random_RangeFloat = _pygame.Random_RangeFloat

class Time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_Time()
        try: self.this.append(this)
        except: self.this = this
    def Start(self): return _pygame.Time_Start(self)
    def GetMilliseconds(self): return _pygame.Time_GetMilliseconds(self)
    __swig_destroy__ = _pygame.delete_Time
    __del__ = lambda self : None;
Time_swigregister = _pygame.Time_swigregister
Time_swigregister(Time)

class Vector2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector2, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pygame.Vector2_x_set
    __swig_getmethods__["x"] = _pygame.Vector2_x_get
    if _newclass:x = _swig_property(_pygame.Vector2_x_get, _pygame.Vector2_x_set)
    __swig_setmethods__["y"] = _pygame.Vector2_y_set
    __swig_getmethods__["y"] = _pygame.Vector2_y_get
    if _newclass:y = _swig_property(_pygame.Vector2_y_get, _pygame.Vector2_y_set)
    __swig_setmethods__["zero"] = _pygame.Vector2_zero_set
    __swig_getmethods__["zero"] = _pygame.Vector2_zero_get
    if _newclass:zero = _swig_property(_pygame.Vector2_zero_get, _pygame.Vector2_zero_set)
    __swig_setmethods__["one"] = _pygame.Vector2_one_set
    __swig_getmethods__["one"] = _pygame.Vector2_one_get
    if _newclass:one = _swig_property(_pygame.Vector2_one_get, _pygame.Vector2_one_set)
    __swig_setmethods__["down"] = _pygame.Vector2_down_set
    __swig_getmethods__["down"] = _pygame.Vector2_down_get
    if _newclass:down = _swig_property(_pygame.Vector2_down_get, _pygame.Vector2_down_set)
    __swig_setmethods__["up"] = _pygame.Vector2_up_set
    __swig_getmethods__["up"] = _pygame.Vector2_up_get
    if _newclass:up = _swig_property(_pygame.Vector2_up_get, _pygame.Vector2_up_set)
    __swig_setmethods__["left"] = _pygame.Vector2_left_set
    __swig_getmethods__["left"] = _pygame.Vector2_left_get
    if _newclass:left = _swig_property(_pygame.Vector2_left_get, _pygame.Vector2_left_set)
    __swig_setmethods__["right"] = _pygame.Vector2_right_set
    __swig_getmethods__["right"] = _pygame.Vector2_right_get
    if _newclass:right = _swig_property(_pygame.Vector2_right_get, _pygame.Vector2_right_set)
    def __init__(self, *args): 
        this = _pygame.new_Vector2(*args)
        try: self.this.append(this)
        except: self.this = this
    def ToB2(self): return _pygame.Vector2_ToB2(self)
    def Set(self, *args): return _pygame.Vector2_Set(self, *args)
    def SetFromAngleDegrees(self, *args): return _pygame.Vector2_SetFromAngleDegrees(self, *args)
    __swig_getmethods__["Random"] = lambda x: _pygame.Vector2_Random
    if _newclass:Random = staticmethod(_pygame.Vector2_Random)
    def LengthSquared(self): return _pygame.Vector2_LengthSquared(self)
    def Length(self): return _pygame.Vector2_Length(self)
    def GetNormalized(self): return _pygame.Vector2_GetNormalized(self)
    def Normalize(self): return _pygame.Vector2_Normalize(self)
    def Clamp(self, *args): return _pygame.Vector2_Clamp(self, *args)
    def IsInRange(self, *args): return _pygame.Vector2_IsInRange(self, *args)
    def DistanceTo(self, *args): return _pygame.Vector2_DistanceTo(self, *args)
    def GetPerpendicularLeft(self): return _pygame.Vector2_GetPerpendicularLeft(self)
    def GetPerpendicularRight(self): return _pygame.Vector2_GetPerpendicularRight(self)
    def Dot(self, *args): return _pygame.Vector2_Dot(self, *args)
    def Cross(self, *args): return _pygame.Vector2_Cross(self, *args)
    def Reflect(self, *args): return _pygame.Vector2_Reflect(self, *args)
    def Project(self, *args): return _pygame.Vector2_Project(self, *args)
    def Rotate(self, *args): return _pygame.Vector2_Rotate(self, *args)
    def GetAngleRadians(self): return _pygame.Vector2_GetAngleRadians(self)
    def GetAngleDegrees(self): return _pygame.Vector2_GetAngleDegrees(self)
    def AngleTo(self, *args): return _pygame.Vector2_AngleTo(self, *args)
    def xx(self): return _pygame.Vector2_xx(self)
    def yy(self): return _pygame.Vector2_yy(self)
    def yx(self): return _pygame.Vector2_yx(self)
    def __eq__(self, *args): return _pygame.Vector2___eq__(self, *args)
    def __ne__(self, *args): return _pygame.Vector2___ne__(self, *args)
    def __iadd__(self, *args): return _pygame.Vector2___iadd__(self, *args)
    def __isub__(self, *args): return _pygame.Vector2___isub__(self, *args)
    def __imul__(self, *args): return _pygame.Vector2___imul__(self, *args)
    def __idiv__(self, *args): return _pygame.Vector2___idiv__(self, *args)
    def __add__(self, *args): return _pygame.Vector2___add__(self, *args)
    def __sub__(self, *args): return _pygame.Vector2___sub__(self, *args)
    def __neg__(self): return _pygame.Vector2___neg__(self)
    def __div__(self, *args): return _pygame.Vector2___div__(self, *args)
    def __mul__(self, *args): return _pygame.Vector2___mul__(self, *args)
    def Load(self, *args): return _pygame.Vector2_Load(self, *args)
    def Save(self, *args): return _pygame.Vector2_Save(self, *args)
    def __str__(self): return _pygame.Vector2___str__(self)
    __swig_destroy__ = _pygame.delete_Vector2
    __del__ = lambda self : None;
Vector2_swigregister = _pygame.Vector2_swigregister
Vector2_swigregister(Vector2)

def Vector2_Random():
  return _pygame.Vector2_Random()
Vector2_Random = _pygame.Vector2_Random

class Transform(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Transform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Transform, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_Transform(*args)
        try: self.this.append(this)
        except: self.this = this
    def LerpTransform(self, *args): return _pygame.Transform_LerpTransform(self, *args)
    def GetDirectionVector(self): return _pygame.Transform_GetDirectionVector(self)
    __swig_setmethods__["position"] = _pygame.Transform_position_set
    __swig_getmethods__["position"] = _pygame.Transform_position_get
    if _newclass:position = _swig_property(_pygame.Transform_position_get, _pygame.Transform_position_set)
    __swig_setmethods__["rotation"] = _pygame.Transform_rotation_set
    __swig_getmethods__["rotation"] = _pygame.Transform_rotation_get
    if _newclass:rotation = _swig_property(_pygame.Transform_rotation_get, _pygame.Transform_rotation_set)
    __swig_setmethods__["scale"] = _pygame.Transform_scale_set
    __swig_getmethods__["scale"] = _pygame.Transform_scale_get
    if _newclass:scale = _swig_property(_pygame.Transform_scale_get, _pygame.Transform_scale_set)
    def Apply(self, *args): return _pygame.Transform_Apply(self, *args)
    def ApplyInverse(self, *args): return _pygame.Transform_ApplyInverse(self, *args)
    def Load(self, *args): return _pygame.Transform_Load(self, *args)
    def Save(self, *args): return _pygame.Transform_Save(self, *args)
    def xAxis(self): return _pygame.Transform_xAxis(self)
    def yAxis(self): return _pygame.Transform_yAxis(self)
    def Multiply(self, *args): return _pygame.Transform_Multiply(self, *args)
    __swig_destroy__ = _pygame.delete_Transform
    __del__ = lambda self : None;
Transform_swigregister = _pygame.Transform_swigregister
Transform_swigregister(Transform)

def __mul__(*args):
  return _pygame.__mul__(*args)
__mul__ = _pygame.__mul__

def __div__(*args):
  return _pygame.__div__(*args)
__div__ = _pygame.__div__

def __rshift__(*args):
  return _pygame.__rshift__(*args)
__rshift__ = _pygame.__rshift__

class TweenVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TweenVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TweenVector, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Update(self, *args): return _pygame.TweenVector_Update(self, *args)
    def SetTime(self, *args): return _pygame.TweenVector_SetTime(self, *args)
    def value(self): return _pygame.TweenVector_value(self)
    def finished(self): return _pygame.TweenVector_finished(self)
    def duration(self): return _pygame.TweenVector_duration(self)
    def time(self): return _pygame.TweenVector_time(self)
    __swig_getmethods__["NoTween"] = lambda x: _pygame.TweenVector_NoTween
    if _newclass:NoTween = staticmethod(_pygame.TweenVector_NoTween)
    __swig_getmethods__["Linear"] = lambda x: _pygame.TweenVector_Linear
    if _newclass:Linear = staticmethod(_pygame.TweenVector_Linear)
    __swig_getmethods__["QuadraticIn"] = lambda x: _pygame.TweenVector_QuadraticIn
    if _newclass:QuadraticIn = staticmethod(_pygame.TweenVector_QuadraticIn)
    __swig_getmethods__["QuadraticOut"] = lambda x: _pygame.TweenVector_QuadraticOut
    if _newclass:QuadraticOut = staticmethod(_pygame.TweenVector_QuadraticOut)
    __swig_getmethods__["QuadraticInOut"] = lambda x: _pygame.TweenVector_QuadraticInOut
    if _newclass:QuadraticInOut = staticmethod(_pygame.TweenVector_QuadraticInOut)
    __swig_getmethods__["SinIn"] = lambda x: _pygame.TweenVector_SinIn
    if _newclass:SinIn = staticmethod(_pygame.TweenVector_SinIn)
    __swig_getmethods__["SinOut"] = lambda x: _pygame.TweenVector_SinOut
    if _newclass:SinOut = staticmethod(_pygame.TweenVector_SinOut)
    __swig_getmethods__["SinInOut"] = lambda x: _pygame.TweenVector_SinInOut
    if _newclass:SinInOut = staticmethod(_pygame.TweenVector_SinInOut)
    __swig_destroy__ = _pygame.delete_TweenVector
    __del__ = lambda self : None;
TweenVector_swigregister = _pygame.TweenVector_swigregister
TweenVector_swigregister(TweenVector)

def TweenVector_NoTween(*args):
  return _pygame.TweenVector_NoTween(*args)
TweenVector_NoTween = _pygame.TweenVector_NoTween

def TweenVector_Linear(*args):
  return _pygame.TweenVector_Linear(*args)
TweenVector_Linear = _pygame.TweenVector_Linear

def TweenVector_QuadraticIn(*args):
  return _pygame.TweenVector_QuadraticIn(*args)
TweenVector_QuadraticIn = _pygame.TweenVector_QuadraticIn

def TweenVector_QuadraticOut(*args):
  return _pygame.TweenVector_QuadraticOut(*args)
TweenVector_QuadraticOut = _pygame.TweenVector_QuadraticOut

def TweenVector_QuadraticInOut(*args):
  return _pygame.TweenVector_QuadraticInOut(*args)
TweenVector_QuadraticInOut = _pygame.TweenVector_QuadraticInOut

def TweenVector_SinIn(*args):
  return _pygame.TweenVector_SinIn(*args)
TweenVector_SinIn = _pygame.TweenVector_SinIn

def TweenVector_SinOut(*args):
  return _pygame.TweenVector_SinOut(*args)
TweenVector_SinOut = _pygame.TweenVector_SinOut

def TweenVector_SinInOut(*args):
  return _pygame.TweenVector_SinInOut(*args)
TweenVector_SinInOut = _pygame.TweenVector_SinInOut

class TweenFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TweenFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TweenFloat, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Update(self, *args): return _pygame.TweenFloat_Update(self, *args)
    def SetTime(self, *args): return _pygame.TweenFloat_SetTime(self, *args)
    def value(self): return _pygame.TweenFloat_value(self)
    def finished(self): return _pygame.TweenFloat_finished(self)
    def duration(self): return _pygame.TweenFloat_duration(self)
    def time(self): return _pygame.TweenFloat_time(self)
    __swig_getmethods__["NoTween"] = lambda x: _pygame.TweenFloat_NoTween
    if _newclass:NoTween = staticmethod(_pygame.TweenFloat_NoTween)
    __swig_getmethods__["Linear"] = lambda x: _pygame.TweenFloat_Linear
    if _newclass:Linear = staticmethod(_pygame.TweenFloat_Linear)
    __swig_getmethods__["QuadraticIn"] = lambda x: _pygame.TweenFloat_QuadraticIn
    if _newclass:QuadraticIn = staticmethod(_pygame.TweenFloat_QuadraticIn)
    __swig_getmethods__["QuadraticOut"] = lambda x: _pygame.TweenFloat_QuadraticOut
    if _newclass:QuadraticOut = staticmethod(_pygame.TweenFloat_QuadraticOut)
    __swig_getmethods__["QuadraticInOut"] = lambda x: _pygame.TweenFloat_QuadraticInOut
    if _newclass:QuadraticInOut = staticmethod(_pygame.TweenFloat_QuadraticInOut)
    __swig_getmethods__["SinIn"] = lambda x: _pygame.TweenFloat_SinIn
    if _newclass:SinIn = staticmethod(_pygame.TweenFloat_SinIn)
    __swig_getmethods__["SinOut"] = lambda x: _pygame.TweenFloat_SinOut
    if _newclass:SinOut = staticmethod(_pygame.TweenFloat_SinOut)
    __swig_getmethods__["SinInOut"] = lambda x: _pygame.TweenFloat_SinInOut
    if _newclass:SinInOut = staticmethod(_pygame.TweenFloat_SinInOut)
    __swig_destroy__ = _pygame.delete_TweenFloat
    __del__ = lambda self : None;
TweenFloat_swigregister = _pygame.TweenFloat_swigregister
TweenFloat_swigregister(TweenFloat)

def TweenFloat_NoTween(*args):
  return _pygame.TweenFloat_NoTween(*args)
TweenFloat_NoTween = _pygame.TweenFloat_NoTween

def TweenFloat_Linear(*args):
  return _pygame.TweenFloat_Linear(*args)
TweenFloat_Linear = _pygame.TweenFloat_Linear

def TweenFloat_QuadraticIn(*args):
  return _pygame.TweenFloat_QuadraticIn(*args)
TweenFloat_QuadraticIn = _pygame.TweenFloat_QuadraticIn

def TweenFloat_QuadraticOut(*args):
  return _pygame.TweenFloat_QuadraticOut(*args)
TweenFloat_QuadraticOut = _pygame.TweenFloat_QuadraticOut

def TweenFloat_QuadraticInOut(*args):
  return _pygame.TweenFloat_QuadraticInOut(*args)
TweenFloat_QuadraticInOut = _pygame.TweenFloat_QuadraticInOut

def TweenFloat_SinIn(*args):
  return _pygame.TweenFloat_SinIn(*args)
TweenFloat_SinIn = _pygame.TweenFloat_SinIn

def TweenFloat_SinOut(*args):
  return _pygame.TweenFloat_SinOut(*args)
TweenFloat_SinOut = _pygame.TweenFloat_SinOut

def TweenFloat_SinInOut(*args):
  return _pygame.TweenFloat_SinInOut(*args)
TweenFloat_SinInOut = _pygame.TweenFloat_SinInOut

class CompositeTweenVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompositeTweenVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompositeTweenVector, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_CompositeTweenVector()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_CompositeTweenVector
    __del__ = lambda self : None;
    def Update(self, *args): return _pygame.CompositeTweenVector_Update(self, *args)
    def SetTime(self, *args): return _pygame.CompositeTweenVector_SetTime(self, *args)
    def AddTween(self, *args): return _pygame.CompositeTweenVector_AddTween(self, *args)
    def value(self): return _pygame.CompositeTweenVector_value(self)
    def finished(self): return _pygame.CompositeTweenVector_finished(self)
CompositeTweenVector_swigregister = _pygame.CompositeTweenVector_swigregister
CompositeTweenVector_swigregister(CompositeTweenVector)

class CompositeTweenFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompositeTweenFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompositeTweenFloat, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_CompositeTweenFloat()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_CompositeTweenFloat
    __del__ = lambda self : None;
    def Update(self, *args): return _pygame.CompositeTweenFloat_Update(self, *args)
    def SetTime(self, *args): return _pygame.CompositeTweenFloat_SetTime(self, *args)
    def AddTween(self, *args): return _pygame.CompositeTweenFloat_AddTween(self, *args)
    def value(self): return _pygame.CompositeTweenFloat_value(self)
    def finished(self): return _pygame.CompositeTweenFloat_finished(self)
CompositeTweenFloat_swigregister = _pygame.CompositeTweenFloat_swigregister
CompositeTweenFloat_swigregister(CompositeTweenFloat)

class BBox(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BBox, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BBox, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min"] = _pygame.BBox_min_set
    __swig_getmethods__["min"] = _pygame.BBox_min_get
    if _newclass:min = _swig_property(_pygame.BBox_min_get, _pygame.BBox_min_set)
    __swig_setmethods__["max"] = _pygame.BBox_max_set
    __swig_getmethods__["max"] = _pygame.BBox_max_get
    if _newclass:max = _swig_property(_pygame.BBox_max_get, _pygame.BBox_max_set)
    def __init__(self, *args): 
        this = _pygame.new_BBox(*args)
        try: self.this.append(this)
        except: self.this = this
    def center(self): return _pygame.BBox_center(self)
    def extents(self): return _pygame.BBox_extents(self)
    def Union(self, *args): return _pygame.BBox_Union(self, *args)
    def IsInside(self, *args): return _pygame.BBox_IsInside(self, *args)
    def BoundingCircle(self, *args): return _pygame.BBox_BoundingCircle(self, *args)
    def Intersects(self, *args): return _pygame.BBox_Intersects(self, *args)
    def Expand(self, *args): return _pygame.BBox_Expand(self, *args)
    __swig_destroy__ = _pygame.delete_BBox
    __del__ = lambda self : None;
BBox_swigregister = _pygame.BBox_swigregister
BBox_swigregister(BBox)

class Vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pygame.Vector3_x_set
    __swig_getmethods__["x"] = _pygame.Vector3_x_get
    if _newclass:x = _swig_property(_pygame.Vector3_x_get, _pygame.Vector3_x_set)
    __swig_setmethods__["y"] = _pygame.Vector3_y_set
    __swig_getmethods__["y"] = _pygame.Vector3_y_get
    if _newclass:y = _swig_property(_pygame.Vector3_y_get, _pygame.Vector3_y_set)
    __swig_setmethods__["z"] = _pygame.Vector3_z_set
    __swig_getmethods__["z"] = _pygame.Vector3_z_get
    if _newclass:z = _swig_property(_pygame.Vector3_z_get, _pygame.Vector3_z_set)
    __swig_setmethods__["zero"] = _pygame.Vector3_zero_set
    __swig_getmethods__["zero"] = _pygame.Vector3_zero_get
    if _newclass:zero = _swig_property(_pygame.Vector3_zero_get, _pygame.Vector3_zero_set)
    __swig_setmethods__["one"] = _pygame.Vector3_one_set
    __swig_getmethods__["one"] = _pygame.Vector3_one_get
    if _newclass:one = _swig_property(_pygame.Vector3_one_get, _pygame.Vector3_one_set)
    __swig_setmethods__["down"] = _pygame.Vector3_down_set
    __swig_getmethods__["down"] = _pygame.Vector3_down_get
    if _newclass:down = _swig_property(_pygame.Vector3_down_get, _pygame.Vector3_down_set)
    __swig_setmethods__["up"] = _pygame.Vector3_up_set
    __swig_getmethods__["up"] = _pygame.Vector3_up_get
    if _newclass:up = _swig_property(_pygame.Vector3_up_get, _pygame.Vector3_up_set)
    __swig_setmethods__["left"] = _pygame.Vector3_left_set
    __swig_getmethods__["left"] = _pygame.Vector3_left_get
    if _newclass:left = _swig_property(_pygame.Vector3_left_get, _pygame.Vector3_left_set)
    __swig_setmethods__["right"] = _pygame.Vector3_right_set
    __swig_getmethods__["right"] = _pygame.Vector3_right_get
    if _newclass:right = _swig_property(_pygame.Vector3_right_get, _pygame.Vector3_right_set)
    def __init__(self, *args): 
        this = _pygame.new_Vector3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Vector3
    __del__ = lambda self : None;
Vector3_swigregister = _pygame.Vector3_swigregister
Vector3_swigregister(Vector3)

class Camera(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Camera, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Camera, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_Camera()
        try: self.this.append(this)
        except: self.this = this
    def ApplyMatrix(self): return _pygame.Camera_ApplyMatrix(self)
    def Update(self): return _pygame.Camera_Update(self)
    def SetLayers(self, *args): return _pygame.Camera_SetLayers(self, *args)
    def backLayer(self): return _pygame.Camera_backLayer(self)
    def frontLayer(self): return _pygame.Camera_frontLayer(self)
    def WatchEntity(self, *args): return _pygame.Camera_WatchEntity(self, *args)
    def watchingEntity(self): return _pygame.Camera_watchingEntity(self)
    def WorldToScreen(self, *args): return _pygame.Camera_WorldToScreen(self, *args)
    def ScreenToWorld(self, *args): return _pygame.Camera_ScreenToWorld(self, *args)
    def worldBounds(self): return _pygame.Camera_worldBounds(self)
    def position(self): return _pygame.Camera_position(self)
    __swig_setmethods__["transform"] = _pygame.Camera_transform_set
    __swig_getmethods__["transform"] = _pygame.Camera_transform_get
    if _newclass:transform = _swig_property(_pygame.Camera_transform_get, _pygame.Camera_transform_set)
    __swig_destroy__ = _pygame.delete_Camera
    __del__ = lambda self : None;
Camera_swigregister = _pygame.Camera_swigregister
Camera_swigregister(Camera)

class Filter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Filter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Filter, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_Filter
    __del__ = lambda self : None;
    def OnAdded(self): return _pygame.Filter_OnAdded(self)
    def OnBottomLayer(self): return _pygame.Filter_OnBottomLayer(self)
    def OnTopLayer(self): return _pygame.Filter_OnTopLayer(self)
    def enabled(self): return _pygame.Filter_enabled(self)
    def setEnabled(self, *args): return _pygame.Filter_setEnabled(self, *args)
    def bottomLayer(self): return _pygame.Filter_bottomLayer(self)
    def topLayer(self): return _pygame.Filter_topLayer(self)
    def name(self): return _pygame.Filter_name(self)
Filter_swigregister = _pygame.Filter_swigregister
Filter_swigregister(Filter)

class SpriteAnimation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpriteAnimation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SpriteAnimation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_SpriteAnimation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_SpriteAnimation
    __del__ = lambda self : None;
    def Update(self): return _pygame.SpriteAnimation_Update(self)
    def Render(self): return _pygame.SpriteAnimation_Render(self)
    def PlayTrack(self, *args): return _pygame.SpriteAnimation_PlayTrack(self, *args)
    def frameUserData(self): return _pygame.SpriteAnimation_frameUserData(self)
    def ReloadSprites(self): return _pygame.SpriteAnimation_ReloadSprites(self)
    def SetXFlip(self, *args): return _pygame.SpriteAnimation_SetXFlip(self, *args)
SpriteAnimation_swigregister = _pygame.SpriteAnimation_swigregister
SpriteAnimation_swigregister(SpriteAnimation)

class AppTime(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppTime, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_AppTime()
        try: self.this.append(this)
        except: self.this = this
    def dt(self): return _pygame.AppTime_dt(self)
    def SetDt(self, *args): return _pygame.AppTime_SetDt(self, *args)
    __swig_getmethods__["Register"] = lambda x: _pygame.AppTime_Register
    if _newclass:Register = staticmethod(_pygame.AppTime_Register)
    __swig_getmethods__["Instance"] = lambda x: _pygame.AppTime_Instance
    if _newclass:Instance = staticmethod(_pygame.AppTime_Instance)
    __swig_destroy__ = _pygame.delete_AppTime
    __del__ = lambda self : None;
AppTime_swigregister = _pygame.AppTime_swigregister
AppTime_swigregister(AppTime)

def AppTime_Register(*args):
  return _pygame.AppTime_Register(*args)
AppTime_Register = _pygame.AppTime_Register

def AppTime_Instance():
  return _pygame.AppTime_Instance()
AppTime_Instance = _pygame.AppTime_Instance

class EntityContactListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EntityContactListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EntityContactListener, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_EntityContactListener
    __del__ = lambda self : None;
    def OnContactBegin(self, *args): return _pygame.EntityContactListener_OnContactBegin(self, *args)
    def OnContactEnd(self, *args): return _pygame.EntityContactListener_OnContactEnd(self, *args)
    def __init__(self): 
        if self.__class__ == EntityContactListener:
            _self = None
        else:
            _self = self
        this = _pygame.new_EntityContactListener(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _pygame.disown_EntityContactListener(self)
        return weakref_proxy(self)
EntityContactListener_swigregister = _pygame.EntityContactListener_swigregister
EntityContactListener_swigregister(EntityContactListener)

class VoltEntity(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VoltEntity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VoltEntity, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_VoltEntity
    __del__ = lambda self : None;
    def layer(self): return _pygame.VoltEntity_layer(self)
    def IsOnLayer(self, *args): return _pygame.VoltEntity_IsOnLayer(self, *args)
    def SetLayer(self, *args): return _pygame.VoltEntity_SetLayer(self, *args)
    def Clone(self): return _pygame.VoltEntity_Clone(self)
    def CopyFrom(self, *args): return _pygame.VoltEntity_CopyFrom(self, *args)
    def scene(self): return _pygame.VoltEntity_scene(self)
    def HasTag(self, *args): return _pygame.VoltEntity_HasTag(self, *args)
    def AddTag(self, *args): return _pygame.VoltEntity_AddTag(self, *args)
    def RemoveTag(self, *args): return _pygame.VoltEntity_RemoveTag(self, *args)
    def GetTags(self, *args): return _pygame.VoltEntity_GetTags(self, *args)
    def numTags(self): return _pygame.VoltEntity_numTags(self)
    def Update(self): return _pygame.VoltEntity_Update(self)
    def Render(self): return _pygame.VoltEntity_Render(self)
    def OnAdded(self): return _pygame.VoltEntity_OnAdded(self)
    def OnRemoved(self): return _pygame.VoltEntity_OnRemoved(self)
    def UpdatePhysics(self): return _pygame.VoltEntity_UpdatePhysics(self)
    def CreateBodyWithDef(self, *args): return _pygame.VoltEntity_CreateBodyWithDef(self, *args)
    def CreateBodyWithType(self, *args): return _pygame.VoltEntity_CreateBodyWithType(self, *args)
    def CreateBodyCustom(self, *args): return _pygame.VoltEntity_CreateBodyCustom(self, *args)
    def DestroyBody(self): return _pygame.VoltEntity_DestroyBody(self)
    def body(self): return _pygame.VoltEntity_body(self)
    def CancelGravity(self): return _pygame.VoltEntity_CancelGravity(self)
    def BeginContact(self, *args): return _pygame.VoltEntity_BeginContact(self, *args)
    def EndContact(self, *args): return _pygame.VoltEntity_EndContact(self, *args)
    def PreSolve(self, *args): return _pygame.VoltEntity_PreSolve(self, *args)
    def CanCollideWith(self, *args): return _pygame.VoltEntity_CanCollideWith(self, *args)
    def RemoveSelf(self): return _pygame.VoltEntity_RemoveSelf(self)
    def transform(self): return _pygame.VoltEntity_transform(self)
    def position(self): return _pygame.VoltEntity_position(self)
    def SetPosition(self, *args): return _pygame.VoltEntity_SetPosition(self, *args)
    def rotation(self): return _pygame.VoltEntity_rotation(self)
    def SetRotation(self, *args): return _pygame.VoltEntity_SetRotation(self, *args)
    def SetLookAt(self, *args): return _pygame.VoltEntity_SetLookAt(self, *args)
    def scale(self): return _pygame.VoltEntity_scale(self)
    def SetScale(self, *args): return _pygame.VoltEntity_SetScale(self, *args)
    def visible(self): return _pygame.VoltEntity_visible(self)
    def setVisible(self, *args): return _pygame.VoltEntity_setVisible(self, *args)
    def OnScaleChanged(self): return _pygame.VoltEntity_OnScaleChanged(self)
    def Load(self, *args): return _pygame.VoltEntity_Load(self, *args)
    def Save(self, *args): return _pygame.VoltEntity_Save(self, *args)
    def AddContactListener(self, *args): return _pygame.VoltEntity_AddContactListener(self, *args)
    def RemoveContactListener(self, *args): return _pygame.VoltEntity_RemoveContactListener(self, *args)
    def ToString(self, *args): return _pygame.VoltEntity_ToString(self, *args)
    def __str__(self): return _pygame.VoltEntity___str__(self)
    def OnTouched(self, callback):
        pylistener = PyEntityContactListener(self, callback, None)
        pylistener.__disown__()
        self.AddContactListener(pylistener)
        return pylistener

    def CreateBody(self, bodyType, dynamic=True, ignoresForces=False,
                   sensor=False):
        self.CreateBodyCustom(bodyType, dynamic, ignoresForces, sensor)

VoltEntity_swigregister = _pygame.VoltEntity_swigregister
VoltEntity_swigregister(VoltEntity)

class FSMState(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FSMState, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FSMState, name)
    __repr__ = _swig_repr
    def __init__(self): 
        if self.__class__ == FSMState:
            _self = None
        else:
            _self = self
        this = _pygame.new_FSMState(_self, )
        try: self.this.append(this)
        except: self.this = this
        self.__disown__()



    __swig_destroy__ = _pygame.delete_FSMState
    __del__ = lambda self : None;
    def Update(self): return _pygame.FSMState_Update(self)
    def OnEnter(self): return _pygame.FSMState_OnEnter(self)
    def OnExit(self): return _pygame.FSMState_OnExit(self)
    def TransitionTo(self, *args): return _pygame.FSMState_TransitionTo(self, *args)
    def DelayTransitionTo(self, *args): return _pygame.FSMState_DelayTransitionTo(self, *args)
    def __disown__(self):
        self.this.disown()
        _pygame.disown_FSMState(self)
        return weakref_proxy(self)
FSMState_swigregister = _pygame.FSMState_swigregister
FSMState_swigregister(FSMState)

def __lshift__(*args):
  return _pygame.__lshift__(*args)
__lshift__ = _pygame.__lshift__

class FSM(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FSM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FSM, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_FSM()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_FSM
    __del__ = lambda self : None;
    def Update(self): return _pygame.FSM_Update(self)
    def TransitionTo(self, *args): return _pygame.FSM_TransitionTo(self, *args)
    def DelayTransitionTo(self, *args): return _pygame.FSM_DelayTransitionTo(self, *args)
    def AddState(self, *args): return _pygame.FSM_AddState(self, *args)
    def stateName(self): return _pygame.FSM_stateName(self)
    def state(self): return _pygame.FSM_state(self)
    def AddStates(self, stateList):
        for state in stateList:
            self.AddState(state[0], state[1])

FSM_swigregister = _pygame.FSM_swigregister
FSM_swigregister(FSM)

class Game(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Game, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Game, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_Game(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Game
    __del__ = lambda self : None;
    def Run(self): return _pygame.Game_Run(self)
    def Quit(self): return _pygame.Game_Quit(self)
    def frameNumber(self): return _pygame.Game_frameNumber(self)
    def fps(self): return _pygame.Game_fps(self)
    def currentScene(self): return _pygame.Game_currentScene(self)
    def SetScene(self, *args): return _pygame.Game_SetScene(self, *args)
    __swig_getmethods__["Register"] = lambda x: _pygame.Game_Register
    if _newclass:Register = staticmethod(_pygame.Game_Register)
    __swig_getmethods__["Instance"] = lambda x: _pygame.Game_Instance
    if _newclass:Instance = staticmethod(_pygame.Game_Instance)
    def OnKeyEvent(self, *args): return _pygame.Game_OnKeyEvent(self, *args)
    def OnMouseButtonEvent(self, *args): return _pygame.Game_OnMouseButtonEvent(self, *args)
    def OnMouseMoveEvent(self, *args): return _pygame.Game_OnMouseMoveEvent(self, *args)
Game_swigregister = _pygame.Game_swigregister
Game_swigregister(Game)

def Game_Register(*args):
  return _pygame.Game_Register(*args)
Game_Register = _pygame.Game_Register

def Game_Instance():
  return _pygame.Game_Instance()
Game_Instance = _pygame.Game_Instance

class PhysicsManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhysicsManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PhysicsManager, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_PhysicsManager()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_PhysicsManager
    __del__ = lambda self : None;
    def Update(self): return _pygame.PhysicsManager_Update(self)
    def Render(self): return _pygame.PhysicsManager_Render(self)
    __swig_getmethods__["Register"] = lambda x: _pygame.PhysicsManager_Register
    if _newclass:Register = staticmethod(_pygame.PhysicsManager_Register)
    __swig_getmethods__["Instance"] = lambda x: _pygame.PhysicsManager_Instance
    if _newclass:Instance = staticmethod(_pygame.PhysicsManager_Instance)
    def world(self): return _pygame.PhysicsManager_world(self)
    def SetGravity(self, *args): return _pygame.PhysicsManager_SetGravity(self, *args)
    def GetGravity(self): return _pygame.PhysicsManager_GetGravity(self)
    def SetDebugDraw(self, *args): return _pygame.PhysicsManager_SetDebugDraw(self, *args)
    def ToggleDebugDraw(self): return _pygame.PhysicsManager_ToggleDebugDraw(self)
    def LockWorld(self): return _pygame.PhysicsManager_LockWorld(self)
    def UnlockWorld(self): return _pygame.PhysicsManager_UnlockWorld(self)
PhysicsManager_swigregister = _pygame.PhysicsManager_swigregister
PhysicsManager_swigregister(PhysicsManager)

def PhysicsManager_Register(*args):
  return _pygame.PhysicsManager_Register(*args)
PhysicsManager_Register = _pygame.PhysicsManager_Register

def PhysicsManager_Instance():
  return _pygame.PhysicsManager_Instance()
PhysicsManager_Instance = _pygame.PhysicsManager_Instance

class Scene(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Scene, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Scene, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_Scene()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Scene
    __del__ = lambda self : None;
    def Render(self): return _pygame.Scene_Render(self)
    def Update(self): return _pygame.Scene_Update(self)
    def OnBegin(self): return _pygame.Scene_OnBegin(self)
    def OnEnd(self): return _pygame.Scene_OnEnd(self)
    def OnPreRender(self): return _pygame.Scene_OnPreRender(self)
    def OnPostRender(self): return _pygame.Scene_OnPostRender(self)
    def Add(self, *args): return _pygame.Scene_Add(self, *args)
    def Remove(self, *args): return _pygame.Scene_Remove(self, *args)
    def RemoveAll(self): return _pygame.Scene_RemoveAll(self)
    def OnEntityLayerChange(self, *args): return _pygame.Scene_OnEntityLayerChange(self, *args)
    def OnEntityTagAdd(self, *args): return _pygame.Scene_OnEntityTagAdd(self, *args)
    def OnEntityTagRemove(self, *args): return _pygame.Scene_OnEntityTagRemove(self, *args)
    def OnKeyEvent(self, *args): return _pygame.Scene_OnKeyEvent(self, *args)
    def OnMouseButtonEvent(self, *args): return _pygame.Scene_OnMouseButtonEvent(self, *args)
    def OnMouseMoveEvent(self, *args): return _pygame.Scene_OnMouseMoveEvent(self, *args)
    def numFilters(self): return _pygame.Scene_numFilters(self)
    def AddFilter(self, *args): return _pygame.Scene_AddFilter(self, *args)
    def RemoveFilter(self, *args): return _pygame.Scene_RemoveFilter(self, *args)
    def GetFilter(self, *args): return _pygame.Scene_GetFilter(self, *args)
    def camera(self): return _pygame.Scene_camera(self)
    def GetEntitiesAtPoint(self, *args): return _pygame.Scene_GetEntitiesAtPoint(self, *args)
    def GetEntitiesInArea(self, *args): return _pygame.Scene_GetEntitiesInArea(self, *args)
    def GetLayerEntityCounts(self, *args): return _pygame.Scene_GetLayerEntityCounts(self, *args)
    def GetEntities(self, *args): return _pygame.Scene_GetEntities(self, *args)
    def SetHook(self, *args): return _pygame.Scene_SetHook(self, *args)
    def AddSceneListener(self, *args): return _pygame.Scene_AddSceneListener(self, *args)
    def RemoveSceneListener(self, *args): return _pygame.Scene_RemoveSceneListener(self, *args)
    def GetFirstTagged(self, *args): return _pygame.Scene_GetFirstTagged(self, *args)
    def GetAllTagged(self, tag):
        entities = EntityVector()
        _pygame.Scene_GetAllTagged(self, tag, entities)
        return entities


Scene_swigregister = _pygame.Scene_swigregister
Scene_swigregister(Scene)

class BlendFilter(Filter):
    __swig_setmethods__ = {}
    for _s in [Filter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BlendFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [Filter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BlendFilter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_BlendFilter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_BlendFilter
    __del__ = lambda self : None;
    def OnAdded(self): return _pygame.BlendFilter_OnAdded(self)
    def OnBottomLayer(self): return _pygame.BlendFilter_OnBottomLayer(self)
    def OnTopLayer(self): return _pygame.BlendFilter_OnTopLayer(self)
    def setBlendAmount(self, *args): return _pygame.BlendFilter_setBlendAmount(self, *args)
    def amount(self): return _pygame.BlendFilter_amount(self)
    def setBlendColor(self, *args): return _pygame.BlendFilter_setBlendColor(self, *args)
    def blendColor(self): return _pygame.BlendFilter_blendColor(self)
BlendFilter_swigregister = _pygame.BlendFilter_swigregister
BlendFilter_swigregister(BlendFilter)

class EdgeFilter(Filter):
    __swig_setmethods__ = {}
    for _s in [Filter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EdgeFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [Filter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EdgeFilter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_EdgeFilter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_EdgeFilter
    __del__ = lambda self : None;
    def OnAdded(self): return _pygame.EdgeFilter_OnAdded(self)
    def OnBottomLayer(self): return _pygame.EdgeFilter_OnBottomLayer(self)
    def OnTopLayer(self): return _pygame.EdgeFilter_OnTopLayer(self)
EdgeFilter_swigregister = _pygame.EdgeFilter_swigregister
EdgeFilter_swigregister(EdgeFilter)

class EntityAccessListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EntityAccessListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EntityAccessListener, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_EntityAccessListener
    __del__ = lambda self : None;
    def OnAccessed(self, *args): return _pygame.EntityAccessListener_OnAccessed(self, *args)
    def __init__(self): 
        if self.__class__ == EntityAccessListener:
            _self = None
        else:
            _self = self
        this = _pygame.new_EntityAccessListener(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _pygame.disown_EntityAccessListener(self)
        return weakref_proxy(self)
EntityAccessListener_swigregister = _pygame.EntityAccessListener_swigregister
EntityAccessListener_swigregister(EntityAccessListener)

class Entity(VoltEntity):
    __swig_setmethods__ = {}
    for _s in [VoltEntity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Entity, name, value)
    __swig_getmethods__ = {}
    for _s in [VoltEntity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Entity, name)
    __repr__ = _swig_repr
    def __init__(self): 
        if self.__class__ == Entity:
            _self = None
        else:
            _self = self
        this = _pygame.new_Entity(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Entity
    __del__ = lambda self : None;
    def GetProperties(self, *args): return _pygame.Entity_GetProperties(self, *args)
    def SetOccludesLight(self, *args): return _pygame.Entity_SetOccludesLight(self, *args)
    def occludesLight(self): return _pygame.Entity_occludesLight(self)
    def OnAccessed(self, callback):
        pylistener = PyEntityAccessListener(self, callback)
        pylistener.__disown__()
        self.AddAccessListener(pylistener)
        return pylistener


    def AddAccessListener(self, *args): return _pygame.Entity_AddAccessListener(self, *args)
    def RemoveAccessListener(self, *args): return _pygame.Entity_RemoveAccessListener(self, *args)
    def Load(self, *args): return _pygame.Entity_Load(self, *args)
    def Save(self, *args): return _pygame.Entity_Save(self, *args)
    def CopyFrom(self, *args): return _pygame.Entity_CopyFrom(self, *args)
    def ToString(self, *args): return _pygame.Entity_ToString(self, *args)
    def SetType(self, *args): return _pygame.Entity_SetType(self, *args)
    def type(self): return _pygame.Entity_type(self)
    def __disown__(self):
        self.this.disown()
        _pygame.disown_Entity(self)
        return weakref_proxy(self)
Entity_swigregister = _pygame.Entity_swigregister
Entity_swigregister(Entity)

class LevelManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LevelManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LevelManager, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_LevelManager(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_LevelManager
    __del__ = lambda self : None;
    def Update(self): return _pygame.LevelManager_Update(self)
    __swig_getmethods__["Register"] = lambda x: _pygame.LevelManager_Register
    if _newclass:Register = staticmethod(_pygame.LevelManager_Register)
    __swig_getmethods__["Instance"] = lambda x: _pygame.LevelManager_Instance
    if _newclass:Instance = staticmethod(_pygame.LevelManager_Instance)
    def LoadLevel(self, *args): return _pygame.LevelManager_LoadLevel(self, *args)
    def LoadLevelFromAssetName(self, *args): return _pygame.LevelManager_LoadLevelFromAssetName(self, *args)
    def LoadLevelFromFilename(self, *args): return _pygame.LevelManager_LoadLevelFromFilename(self, *args)
    def UnloadLevel(self): return _pygame.LevelManager_UnloadLevel(self)
    def SaveLevel(self, *args): return _pygame.LevelManager_SaveLevel(self, *args)
    def RequestLevelChange(self, *args): return _pygame.LevelManager_RequestLevelChange(self, *args)
    def loadedFile(self): return _pygame.LevelManager_loadedFile(self)
    def levelName(self): return _pygame.LevelManager_levelName(self)
    def SetLevelName(self, *args): return _pygame.LevelManager_SetLevelName(self, *args)
    def IsUnloading(self): return _pygame.LevelManager_IsUnloading(self)
    def SetPythonInitScriptsEnabled(self, *args): return _pygame.LevelManager_SetPythonInitScriptsEnabled(self, *args)
    def pythonInitScriptsEnabled(self): return _pygame.LevelManager_pythonInitScriptsEnabled(self)
    def startScript(self): return _pygame.LevelManager_startScript(self)
    def SetStartScript(self, *args): return _pygame.LevelManager_SetStartScript(self, *args)
LevelManager_swigregister = _pygame.LevelManager_swigregister
LevelManager_swigregister(LevelManager)

def LevelManager_Register(*args):
  return _pygame.LevelManager_Register(*args)
LevelManager_Register = _pygame.LevelManager_Register

def LevelManager_Instance():
  return _pygame.LevelManager_Instance()
LevelManager_Instance = _pygame.LevelManager_Instance

class SaveData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SaveData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SaveData, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_SaveData(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_SaveData
    __del__ = lambda self : None;
    __swig_getmethods__["Register"] = lambda x: _pygame.SaveData_Register
    if _newclass:Register = staticmethod(_pygame.SaveData_Register)
    __swig_getmethods__["Instance"] = lambda x: _pygame.SaveData_Instance
    if _newclass:Instance = staticmethod(_pygame.SaveData_Instance)
    def Load(self): return _pygame.SaveData_Load(self)
    def Unload(self): return _pygame.SaveData_Unload(self)
    def Save(self): return _pygame.SaveData_Save(self)
    def GetFlag(self, *args): return _pygame.SaveData_GetFlag(self, *args)
    def SetFlag(self, *args): return _pygame.SaveData_SetFlag(self, *args)
    def GetFloat(self, *args): return _pygame.SaveData_GetFloat(self, *args)
    def SetFloat(self, *args): return _pygame.SaveData_SetFloat(self, *args)
    def GetInt(self, *args): return _pygame.SaveData_GetInt(self, *args)
    def SetInt(self, *args): return _pygame.SaveData_SetInt(self, *args)
    def Increment(self, *args): return _pygame.SaveData_Increment(self, *args)
SaveData_swigregister = _pygame.SaveData_swigregister
SaveData_swigregister(SaveData)

def SaveData_Register(*args):
  return _pygame.SaveData_Register(*args)
SaveData_Register = _pygame.SaveData_Register

def SaveData_Instance():
  return _pygame.SaveData_Instance()
SaveData_Instance = _pygame.SaveData_Instance

class CreatureListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CreatureListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CreatureListener, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_CreatureListener
    __del__ = lambda self : None;
    def OnDamage(self, *args): return _pygame.CreatureListener_OnDamage(self, *args)
    def OnDeath(self, *args): return _pygame.CreatureListener_OnDeath(self, *args)
    def __init__(self): 
        this = _pygame.new_CreatureListener()
        try: self.this.append(this)
        except: self.this = this
CreatureListener_swigregister = _pygame.CreatureListener_swigregister
CreatureListener_swigregister(CreatureListener)

class Creature(Entity):
    __swig_setmethods__ = {}
    for _s in [Entity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Creature, name, value)
    __swig_getmethods__ = {}
    for _s in [Entity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Creature, name)
    __repr__ = _swig_repr
    def __init__(self): 
        if self.__class__ == Creature:
            _self = None
        else:
            _self = self
        this = _pygame.new_Creature(_self, )
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Creature
    __del__ = lambda self : None;
    def OnRemoved(self): return _pygame.Creature_OnRemoved(self)
    def Update(self): return _pygame.Creature_Update(self)
    def Render(self): return _pygame.Creature_Render(self)
    def EquipWeapon(self, *args): return _pygame.Creature_EquipWeapon(self, *args)
    def AddListener(self, *args): return _pygame.Creature_AddListener(self, *args)
    def RemoveListener(self, *args): return _pygame.Creature_RemoveListener(self, *args)
    def weaponTransform(self): return _pygame.Creature_weaponTransform(self)
    def ToString(self, *args): return _pygame.Creature_ToString(self, *args)
    def TakeDamage(self, *args): return _pygame.Creature_TakeDamage(self, *args)
    def __disown__(self):
        self.this.disown()
        _pygame.disown_Creature(self)
        return weakref_proxy(self)
Creature_swigregister = _pygame.Creature_swigregister
Creature_swigregister(Creature)

class LightStroke(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LightStroke, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LightStroke, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vertices"] = _pygame.LightStroke_vertices_set
    __swig_getmethods__["vertices"] = _pygame.LightStroke_vertices_get
    if _newclass:vertices = _swig_property(_pygame.LightStroke_vertices_get, _pygame.LightStroke_vertices_set)
    __swig_setmethods__["color"] = _pygame.LightStroke_color_set
    __swig_getmethods__["color"] = _pygame.LightStroke_color_get
    if _newclass:color = _swig_property(_pygame.LightStroke_color_get, _pygame.LightStroke_color_set)
    def Load(self, *args): return _pygame.LightStroke_Load(self, *args)
    def Save(self, *args): return _pygame.LightStroke_Save(self, *args)
    def __init__(self): 
        this = _pygame.new_LightStroke()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_LightStroke
    __del__ = lambda self : None;
LightStroke_swigregister = _pygame.LightStroke_swigregister
LightStroke_swigregister(LightStroke)

class Light(Entity):
    __swig_setmethods__ = {}
    for _s in [Entity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Light, name, value)
    __swig_getmethods__ = {}
    for _s in [Entity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Light, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_Light()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Light
    __del__ = lambda self : None;
    def Clone(self): return _pygame.Light_Clone(self)
    def CopyFrom(self, *args): return _pygame.Light_CopyFrom(self, *args)
    def OnAdded(self): return _pygame.Light_OnAdded(self)
    def OnRemoved(self): return _pygame.Light_OnRemoved(self)
    def Update(self): return _pygame.Light_Update(self)
    def Render(self): return _pygame.Light_Render(self)
    def Load(self, *args): return _pygame.Light_Load(self, *args)
    def Save(self, *args): return _pygame.Light_Save(self, *args)
    def OnScaleChanged(self): return _pygame.Light_OnScaleChanged(self)
    def GetProperties(self, *args): return _pygame.Light_GetProperties(self, *args)
    def color(self): return _pygame.Light_color(self)
    def maxDistance(self): return _pygame.Light_maxDistance(self)
    def coneAngle(self): return _pygame.Light_coneAngle(self)
    def InvalidateStaticMap(self): return _pygame.Light_InvalidateStaticMap(self)
    def GenerateStrokes(self): return _pygame.Light_GenerateStrokes(self)
    def renderBounds(self): return _pygame.Light_renderBounds(self)
Light_swigregister = _pygame.Light_swigregister
Light_swigregister(Light)

class Player(Creature):
    __swig_setmethods__ = {}
    for _s in [Creature]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Player, name, value)
    __swig_getmethods__ = {}
    for _s in [Creature]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Player, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_Player()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Player
    __del__ = lambda self : None;
    def Update(self): return _pygame.Player_Update(self)
    def Render(self): return _pygame.Player_Render(self)
    def OnKeyEvent(self, *args): return _pygame.Player_OnKeyEvent(self, *args)
    def OnAdded(self): return _pygame.Player_OnAdded(self)
    def OnRemoved(self): return _pygame.Player_OnRemoved(self)
    def IsOnGround(self): return _pygame.Player_IsOnGround(self)
Player_swigregister = _pygame.Player_swigregister
Player_swigregister(Player)

class BrushStroke(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BrushStroke, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BrushStroke, name)
    __repr__ = _swig_repr
    __swig_setmethods__["transform"] = _pygame.BrushStroke_transform_set
    __swig_getmethods__["transform"] = _pygame.BrushStroke_transform_get
    if _newclass:transform = _swig_property(_pygame.BrushStroke_transform_get, _pygame.BrushStroke_transform_set)
    __swig_setmethods__["color"] = _pygame.BrushStroke_color_set
    __swig_getmethods__["color"] = _pygame.BrushStroke_color_get
    if _newclass:color = _swig_property(_pygame.BrushStroke_color_get, _pygame.BrushStroke_color_set)
    def __init__(self): 
        this = _pygame.new_BrushStroke()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_BrushStroke
    __del__ = lambda self : None;
BrushStroke_swigregister = _pygame.BrushStroke_swigregister
BrushStroke_swigregister(BrushStroke)

class Triangle(Entity):
    __swig_setmethods__ = {}
    for _s in [Entity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Triangle, name, value)
    __swig_getmethods__ = {}
    for _s in [Entity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Triangle, name)
    __repr__ = _swig_repr
    NUM_VERTS = _pygame.Triangle_NUM_VERTS
    def __init__(self): 
        this = _pygame.new_Triangle()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_Triangle
    __del__ = lambda self : None;
    def OnAdded(self): return _pygame.Triangle_OnAdded(self)
    def Clone(self): return _pygame.Triangle_Clone(self)
    def CopyFrom(self, *args): return _pygame.Triangle_CopyFrom(self, *args)
    def Update(self): return _pygame.Triangle_Update(self)
    def Render(self): return _pygame.Triangle_Render(self)
    def Load(self, *args): return _pygame.Triangle_Load(self, *args)
    def Save(self, *args): return _pygame.Triangle_Save(self, *args)
    def selectedVertex(self, *args): return _pygame.Triangle_selectedVertex(self, *args)
    def OnScaleChanged(self): return _pygame.Triangle_OnScaleChanged(self)
    def GetProperties(self, *args): return _pygame.Triangle_GetProperties(self, *args)
Triangle_swigregister = _pygame.Triangle_swigregister
Triangle_swigregister(Triangle)

class EntityFactory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EntityFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EntityFactory, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_EntityFactory()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_EntityFactory
    __del__ = lambda self : None;
    __swig_getmethods__["Create"] = lambda x: _pygame.EntityFactory_Create
    if _newclass:Create = staticmethod(_pygame.EntityFactory_Create)
    __swig_getmethods__["GetEntityTypes"] = lambda x: _pygame.EntityFactory_GetEntityTypes
    if _newclass:GetEntityTypes = staticmethod(_pygame.EntityFactory_GetEntityTypes)
EntityFactory_swigregister = _pygame.EntityFactory_swigregister
EntityFactory_swigregister(EntityFactory)

def EntityFactory_Create(*args):
  return _pygame.EntityFactory_Create(*args)
EntityFactory_Create = _pygame.EntityFactory_Create

def EntityFactory_GetEntityTypes(*args):
  return _pygame.EntityFactory_GetEntityTypes(*args)
EntityFactory_GetEntityTypes = _pygame.EntityFactory_GetEntityTypes

class DialogListener(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogListener, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DialogListener, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_DialogListener
    __del__ = lambda self : None;
    def OnDialogFinished(self): return _pygame.DialogListener_OnDialogFinished(self)
    def __init__(self): 
        if self.__class__ == DialogListener:
            _self = None
        else:
            _self = self
        this = _pygame.new_DialogListener(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _pygame.disown_DialogListener(self)
        return weakref_proxy(self)
DialogListener_swigregister = _pygame.DialogListener_swigregister
DialogListener_swigregister(DialogListener)

class DialogBox(Entity):
    __swig_setmethods__ = {}
    for _s in [Entity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogBox, name, value)
    __swig_getmethods__ = {}
    for _s in [Entity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DialogBox, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pygame.delete_DialogBox
    __del__ = lambda self : None;
    def IsFinished(self): return _pygame.DialogBox_IsFinished(self)
    def modal(self): return _pygame.DialogBox_modal(self)
    def Update(self): return _pygame.DialogBox_Update(self)
    def Render(self): return _pygame.DialogBox_Render(self)
    def SetFont(self, *args): return _pygame.DialogBox_SetFont(self, *args)
    def OnKeyEvent(self, *args): return _pygame.DialogBox_OnKeyEvent(self, *args)
    def Load(self, *args): return _pygame.DialogBox_Load(self, *args)
    def Save(self, *args): return _pygame.DialogBox_Save(self, *args)
    __swig_getmethods__["ProcessText"] = lambda x: _pygame.DialogBox_ProcessText
    if _newclass:ProcessText = staticmethod(_pygame.DialogBox_ProcessText)
    def AddDialogListener(self, *args): return _pygame.DialogBox_AddDialogListener(self, *args)
    def RemoveDialogListener(self, *args): return _pygame.DialogBox_RemoveDialogListener(self, *args)
DialogBox_swigregister = _pygame.DialogBox_swigregister
DialogBox_swigregister(DialogBox)

def DialogBox_ProcessText(*args):
  return _pygame.DialogBox_ProcessText(*args)
DialogBox_ProcessText = _pygame.DialogBox_ProcessText

class ChoiceBoxDef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChoiceBoxDef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ChoiceBoxDef, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_ChoiceBoxDef()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["text"] = _pygame.ChoiceBoxDef_text_set
    __swig_getmethods__["text"] = _pygame.ChoiceBoxDef_text_get
    if _newclass:text = _swig_property(_pygame.ChoiceBoxDef_text_get, _pygame.ChoiceBoxDef_text_set)
    __swig_setmethods__["choices"] = _pygame.ChoiceBoxDef_choices_set
    __swig_getmethods__["choices"] = _pygame.ChoiceBoxDef_choices_get
    if _newclass:choices = _swig_property(_pygame.ChoiceBoxDef_choices_get, _pygame.ChoiceBoxDef_choices_set)
    __swig_destroy__ = _pygame.delete_ChoiceBoxDef
    __del__ = lambda self : None;
ChoiceBoxDef_swigregister = _pygame.ChoiceBoxDef_swigregister
ChoiceBoxDef_swigregister(ChoiceBoxDef)

class ChoiceBox(DialogBox):
    __swig_setmethods__ = {}
    for _s in [DialogBox]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChoiceBox, name, value)
    __swig_getmethods__ = {}
    for _s in [DialogBox]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChoiceBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_ChoiceBox(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_ChoiceBox
    __del__ = lambda self : None;
    def Update(self): return _pygame.ChoiceBox_Update(self)
    def Render(self): return _pygame.ChoiceBox_Render(self)
    def modal(self): return _pygame.ChoiceBox_modal(self)
    def OnAdded(self): return _pygame.ChoiceBox_OnAdded(self)
    def choice(self): return _pygame.ChoiceBox_choice(self)
    def OnKeyEvent(self, *args): return _pygame.ChoiceBox_OnKeyEvent(self, *args)
    def WaitForChoice(self):
        class ChoiceFinishListener(DialogListener):
            def __init__(self, choiceBox, alertSemaphore):
                DialogListener.__init__(self)
                self.__disown__()
                self.choiceBox = choiceBox
                self.choice = -1
                self.alertSemaphore = alertSemaphore

            def OnDialogFinished(self):
                self.choice = self.choiceBox.choice()
                self.alertSemaphore.release()

        semaphore = threading.Semaphore(0)
        listener = ChoiceFinishListener(self, semaphore)
        self.AddDialogListener(listener)

        semaphore.acquire()

        return listener.choice

ChoiceBox_swigregister = _pygame.ChoiceBox_swigregister
ChoiceBox_swigregister(ChoiceBox)

class MessageBoxDef(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MessageBoxDef, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MessageBoxDef, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_MessageBoxDef()
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["text"] = _pygame.MessageBoxDef_text_set
    __swig_getmethods__["text"] = _pygame.MessageBoxDef_text_get
    if _newclass:text = _swig_property(_pygame.MessageBoxDef_text_get, _pygame.MessageBoxDef_text_set)
    __swig_setmethods__["modal"] = _pygame.MessageBoxDef_modal_set
    __swig_getmethods__["modal"] = _pygame.MessageBoxDef_modal_get
    if _newclass:modal = _swig_property(_pygame.MessageBoxDef_modal_get, _pygame.MessageBoxDef_modal_set)
    __swig_setmethods__["canSkip"] = _pygame.MessageBoxDef_canSkip_set
    __swig_getmethods__["canSkip"] = _pygame.MessageBoxDef_canSkip_get
    if _newclass:canSkip = _swig_property(_pygame.MessageBoxDef_canSkip_get, _pygame.MessageBoxDef_canSkip_set)
    __swig_setmethods__["pauseDuration"] = _pygame.MessageBoxDef_pauseDuration_set
    __swig_getmethods__["pauseDuration"] = _pygame.MessageBoxDef_pauseDuration_get
    if _newclass:pauseDuration = _swig_property(_pygame.MessageBoxDef_pauseDuration_get, _pygame.MessageBoxDef_pauseDuration_set)
    __swig_destroy__ = _pygame.delete_MessageBoxDef
    __del__ = lambda self : None;
MessageBoxDef_swigregister = _pygame.MessageBoxDef_swigregister
MessageBoxDef_swigregister(MessageBoxDef)

class MessageBox(DialogBox):
    __swig_setmethods__ = {}
    for _s in [DialogBox]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MessageBox, name, value)
    __swig_getmethods__ = {}
    for _s in [DialogBox]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MessageBox, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _pygame.new_MessageBox(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_MessageBox
    __del__ = lambda self : None;
    def Update(self): return _pygame.MessageBox_Update(self)
    def Render(self): return _pygame.MessageBox_Render(self)
    def OnAdded(self): return _pygame.MessageBox_OnAdded(self)
    def modal(self): return _pygame.MessageBox_modal(self)
    def OnKeyEvent(self, *args): return _pygame.MessageBox_OnKeyEvent(self, *args)
    def WaitForFinish(self):
        class DialogFinishListener(DialogListener):
            def __init__(self, alertSemaphore):
                DialogListener.__init__(self)
                self.__disown__()
                self.alertSemaphore = alertSemaphore

            def OnDialogFinished(self):
                self.alertSemaphore.release()

        semaphore = threading.Semaphore(0)
        listener = DialogFinishListener(semaphore)
        self.AddDialogListener(listener)

        semaphore.acquire()

MessageBox_swigregister = _pygame.MessageBox_swigregister
MessageBox_swigregister(MessageBox)

class GameScene(Scene):
    __swig_setmethods__ = {}
    for _s in [Scene]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GameScene, name, value)
    __swig_getmethods__ = {}
    for _s in [Scene]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GameScene, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _pygame.new_GameScene()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pygame.delete_GameScene
    __del__ = lambda self : None;
    def Update(self): return _pygame.GameScene_Update(self)
    def OnBegin(self): return _pygame.GameScene_OnBegin(self)
    def OnEnd(self): return _pygame.GameScene_OnEnd(self)
    def OnKeyEvent(self, *args): return _pygame.GameScene_OnKeyEvent(self, *args)
    def ShowDialogBox(self, *args): return _pygame.GameScene_ShowDialogBox(self, *args)
    def SetPlayerInputLock(self, *args): return _pygame.GameScene_SetPlayerInputLock(self, *args)
    def player(self): return _pygame.GameScene_player(self)
GameScene_swigregister = _pygame.GameScene_swigregister
GameScene_swigregister(GameScene)

from core.pygamecore import *


def GameEntity(*args):
  return _pygame.GameEntity(*args)
GameEntity = _pygame.GameEntity

def CreatureCast(*args):
  return _pygame.CreatureCast(*args)
CreatureCast = _pygame.CreatureCast

def scene():
  return _pygame.scene()
scene = _pygame.scene


